# Подсчёт числа несовпадающих символов двух строк (SEQ + MPI)

- **Студент:** Сизов Дмитрий Игоревич, группа 3823Б1ФИ2  
- **Технология:** SEQ | MPI  
- **Вариант:** №27  

---

## 1. Введение

Цель работы — реализовать алгоритм определения количества несовпадающих символов в двух строках одинаковой длины, а затем распараллелить вычисления с помощью технологии MPI.

Параллелизация позволяет ускорить вычисления при больших объёмах данных за счёт распределения работы между процессами.

---

## 2. Постановка задачи

Даны две строки `A` и `B` одинаковой длины `n`.

Требуется определить количество индексов, на которых символы отличаются:

```
count = |{ i | A[i] != B[i], 0 <= i < n }|
```

Тип входных и выходных данных задан в `common.hpp`:

```cpp
using InType  = std::tuple<std::string, std::string>;
using OutType = int;
```

Ограничения:

- строки должны быть одинаковой длины;

---

## 3. Базовый алгоритм (последовательная версия)

Алгоритм проходит по символам строк и сравнивает их:

**Псевдокод:**

```
count = 0
for i in 0..n-1:
    if A[i] != B[i]:
        count += 1
return count
```

**Характеристики:**

| Параметр                  | Значение |
|---------------------------|----------|
| Сложность по времени      | O(n)     |
| Сложность по памяти       | O(1)     |

Реализация расположена в `ops_seq.cpp`.

---

## 4. Схема распараллеливания (MPI)

Параллельная версия разбивает строки на подстроки и распределяет их между MPI-процессами.

### 4.1 Распределение данных

Используется `MPI_Scatterv`, позволяющий отправлять разные размеры блоков разным процессам.

### 4.2 Сбор результата

После локального сравнения каждого фрагмента:

- `MPI_Reduce` суммирует частичные результаты на процессе 0;
- `MPI_Bcast` сообщает итог всем процессам.

Фрагмент (`ops_mpi.cpp`):

```cpp
MPI_Scatterv(str_a_.data(), counts.data(), displs.data(), MPI_CHAR,
             local_a.data(), local_size, MPI_CHAR, 0, MPI_COMM_WORLD);

MPI_Scatterv(str_b_.data(), counts.data(), displs.data(), MPI_CHAR,
             local_b.data(), local_size, MPI_CHAR, 0, MPI_COMM_WORLD);

int local_result = 0;
for (int i = 0; i < local_size; ++i)
    if (local_a[i] != local_b[i])
        ++local_result;

MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);
MPI_Bcast(&global_result, 1, MPI_INT, 0, MPI_COMM_WORLD);

GetOutput() = global_result;
```

---

## 5. Детали реализации проекта

Структура проекта:

|          Файл          |                 Назначение                  |
|------------------------|---------------------------------------------|
| `common.hpp`           | Определение входных и выходных типов задачи |
| `ops_seq.hpp/.cpp`     |         Последовательная реализация         |
| `ops_mpi.hpp/.cpp`     |                MPI-реализация               |
| `functional/main.cpp`  |             Функциональные тесты            |
| `performance/main.cpp` |       Тестирование производительности       |

Валидация входных данных выполняется в методе `ValidationImpl()`.

---

## 6. Экспериментальная среда

|  Компонент |               Значение                 |
|------------|----------------------------------------|
|     CPU    | 12th Gen Intel(R) Core(TM) i5-12450H   |
|     RAM    |                 16 GB                  |
|     ОС     | OS: Ubuntu 24.04 (DevContainer / WSL2) |
| Компилятор | GCC 13.3.0 (g++), C++20, CMake, Release|
|     MPI    |          mpirun (Open MPI) 4.1.6       |

Тестирование производительности выполнялось на строках длиной:

```
1 000 000 символов
```

---

## 7. Результаты и обсуждение

### 7.1 Проверка корректности

В функциональных тестах (`functional/main.cpp`) используются входные файлы:

```
strings1.txt
strings2.txt
...
strings10.txt
```

Обе реализации (SEQ и MPI) дают одинаковый результат → алгоритм корректен.

---

### 7.2 Производительность

В `performance/main.cpp`:

- строка `A` → `'a' * 1 000 000`
- строка `B` → копия `A`, но каждый 10-й символ заменён на `'b'`
- ожидаемое количество несовпадений: `100000`

Пример полученных результатов (зависят от процессора):

| Режим | Количество процессов |    Время, с  | Ускорение  | Эффективность |
|-------|----------------------|--------------|------------|---------------|
| SEQ   | 1                    | 0.0067229748 | 1.00       | N/A           |
| MPI   | 2                    | 0.0021482308 | 3.128      | 156%          |
| MPI   | 4                    | 0.0012343032 | 5.447      | 136.2 %       |

---

## 8. Заключение

В ходе выполнения работы:

- Реализован алгоритм подсчёта несовпадающих символов двух строк;
- Созданы SEQ и MPI версии;
- MPI версия показала ускорение на больших входных данных;

---

## 9. Источники

- Гергель В.П. Высокопроизводительные вычисления для многопроцессорных многоядерных систем. Серия «Суперкомпьютерное образование».
- Гергель В.П. Теория и практика параллельных вычислений. – М.: Интуит Бином. Лаборатория знаний, 2007.
- Wilkinson B., Allen M. Parallel programming: techniques and applications using networked workstations and parallel computers. – Prentice Hall, 1999.