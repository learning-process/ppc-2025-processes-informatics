# Подсчёт числа несовпадающих символов двух строк (SEQ + MPI)

- **Студент:** Сизов Дмитрий Игоревич, группа 3823Б1ФИ2  
- **Технология:** SEQ | MPI  
- **Вариант:** №27  

---

## 1. Введение

Цель работы — реализовать алгоритм определения количества несовпадающих символов в двух строках одинаковой длины, а затем распараллелить вычисления с помощью технологии MPI.

Параллелизация позволяет ускорить вычисления при больших объёмах данных за счёт распределения работы между процессами.

---

## 2. Постановка задачи

Даны две строки `A` и `B` одинаковой длины `n`.

Требуется определить количество индексов i , на которых символы отличаются:

```
count = |{ i | A[i] != B[i], 0 <= i < n }|
```

Тип входных и выходных данных задан в `common.hpp`:

```cpp
using InType  = std::tuple<std::string, std::string>;
using OutType = int;
```

Ограничения:

- строки должны быть одинаковой длины;

---

## 3. Базовый алгоритм (последовательная версия)

Алгоритм проходит по символам строк и сравнивает их:

**Псевдокод:**

```
count = 0
for i in 0..n-1:
    if A[i] != B[i]:
        count += 1
return count
```

**Характеристики:**

| Параметр                  | Значение |
|---------------------------|----------|
| Сложность по времени      | O(n)     |
| Сложность по памяти       | O(1)     |

Реализация расположена в `ops_seq.cpp`.

---

## 4. Схема распараллеливания (MPI)

Параллельная реализация использует **распараллеливание по данным**:  
исходные строки разбиваются на фрагменты, и каждый MPI-процесс сравнивает только свой участок.

---

### 4.1 Распределение данных

Для рассылки различных по размеру блоков используется операция `MPI_Scatterv`.  
Перед отправкой рассчитываются два массива:

| Массив      | Назначение                                     |
|-------------|------------------------------------------------|
| `counts[i]` | количество символов, передаваемое процессу     |
| `displs[i]` | смещение начала блока в исходной строке        |

Фрагменты строк `A` и `B` отправляются каждому процессу:

```cpp
MPI_Scatterv(str_a_.data(), counts.data(), displs.data(), MPI_CHAR,
             local_a.data(), local_size, MPI_CHAR, 0, MPI_COMM_WORLD);

MPI_Scatterv(str_b_.data(), counts.data(), displs.data(), MPI_CHAR,
             local_b.data(), local_size, MPI_CHAR, 0, MPI_COMM_WORLD);
```

---

### 4.2 Локальные вычисления

Каждый процесс сравнивает только свой участок строк:

```cpp
int local_result = 0;
for (int i = 0; i < local_size; ++i)
    if (local_a[i] != local_b[i])
        ++local_result;
```
---

### 4.3 Сбор и рассылка результата

1. `MPI_Reduce` суммирует частичные результаты на процессе `rank = 0`:

```cpp
MPI_Reduce(&local_result, &global_result, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);
```

2. `MPI_Bcast` рассылает итог всем процессам:

```cpp
MPI_Bcast(&global_result, 1, MPI_INT, 0, MPI_COMM_WORLD);
```

3. Сохранение результата:

```cpp
GetOutput() = global_result;
```

---

### Схема работы

```
┌──────────────────────────────┐
│          Процесс 0           │
│  содержит исходные строки A,B│
└────────┬─────────────────────┘
         │ MPI_Scatterv
         ↓
 ┌────────────────┬────────────────┬────────────────┐
 │  Процесс 0     │  Процесс 1     │  Процесс 2     │   ...
 │ получает A₀,B₀ │ получает A₁,B₁ │ получает A₂,B₂ │
 │ (фрагмент)     │ (фрагмент)     │ (фрагмент)     │
 └───────┬────────┴────────────────┴────────────────┘
         │ локальные вычисления
         ↓
 ┌────────────────┬────────────────┬────────────────┐
 │ local_result₀  │ local_result₁  │ local_result₂  │
 └───────┬────────┴────────────────┴────────────────┘
         │ MPI_Reduce
         ↓
┌───────────────────────────────────┐
│  Процесс 0 получает global_result │
└────────┬──────────────────────────┘
         │ MPI_Bcast
         ↓
┌─────────────────────────────────────────────┐
│   Все процессы получают итоговое значение   │
│  Сохранение: GetOutput() = global_result    │
└─────────────────────────────────────────────┘

```


---

## 5. Детали реализации проекта

### 5.1 Структура проекта:

|          Файл          |                 Назначение                  |
|------------------------|---------------------------------------------|
| `common.hpp`           | Определение входных и выходных типов задачи |
| `ops_seq.hpp/.cpp`     |         Последовательная реализация         |
| `ops_mpi.hpp/.cpp`     |                MPI-реализация               |
| `functional/main.cpp`  |             Функциональные тесты            |
| `performance/main.cpp` |       Тестирование производительности       |

### 5.2 Дополнительная функция `TrimString`:
В функциональных тестах строки считываются из текстовых файлов.  
При чтении строк через `std::getline` в конце строки могут присутствовать скрытые управляющие символы.
Эти символы не являются частью строковых данных, но могут случайно попасть в начало или конец строки при чтении файла. Это приводит к тому, что строки, визуально выглядящие одинаковыми, имеют разную длину и дают ложные несовпадения при сравнении.
Чтобы это исключить, перед передачей строк в алгоритм вызывается функция `TrimString`.
Примечание: пробел считается как полноценный символ и может быть отличен от других символов. В таком случае программа обработает это как отличие.

---

## 6. Экспериментальная среда

|  Компонент |               Значение                 |
|------------|----------------------------------------|
|     CPU    | 12th Gen Intel(R) Core(TM) i5-12450H   |
|     RAM    |                 16 GB                  |
|     ОС     | OS: Ubuntu 24.04 (DevContainer / WSL2) |
| Компилятор | GCC 13.3.0 (g++), C++20, CMake, Release|
|     MPI    |        mpirun (Open MPI) 4.1.6         |

Тестирование производительности выполнялось на строках длиной:

```
1 000 000 символов
```

---

## 7. Результаты и обсуждение

### 7.1 Проверка корректности

В функциональных тестах (`functional/main.cpp`) используются входные файлы:

```
strings1.txt
strings2.txt
...
strings10.txt
```
Формат входного файла: первая и вторая строка это последовательность сравниваемых символов, 3-я строка - истинное кол-во отличий.
Обе реализации (SEQ и MPI) дают одинаковый (правильный) ответ при при всех тестах.
---

### 7.2 Производительность

В `performance/main.cpp`:

- строка `A` → `'a' * 15 000 000`
- строка `B` это копия `A`, но 10% символов заменили на `'b'`
- ожидаемое количество несовпадений: `1 500 000`

Полученные результаты:

Для метрик «Время», «Ускорение», «Эффективность» использовалось время task_run.

| Режим | Количество процессов |    Время, с  | Ускорение  | Эффективность |
|-------|----------------------|--------------|------------|---------------|
| SEQ   | 1                    | 0.0880744457 | 1.00       | N/A           |
| MPI   | 2                    | 0.0513934062 | 1.71       | 85.5%         |
| MPI   | 4                    | 0.0410078336 | 2.15       | 53.8%         |

---

## 8. Заключение

В ходе выполнения работы:

- Реализован алгоритм подсчёта несовпадающих символов двух строк;
- Созданы SEQ и MPI версии;
- MPI версия показала ускорение на больших входных данных;

---

## 9. Источники

- Гергель В.П. Высокопроизводительные вычисления для многопроцессорных многоядерных систем. Серия «Суперкомпьютерное образование».
- Гергель В.П. Теория и практика параллельных вычислений. – М.: Интуит Бином. Лаборатория знаний, 2007.
- Wilkinson B., Allen M. Parallel programming: techniques and applications using networked workstations and parallel computers. – Prentice Hall, 1999.