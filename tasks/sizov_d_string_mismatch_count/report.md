### Отчёт по задаче: "Подсчет числа несовпадающих символов двух строк"  
**Вариант:** №27  
**Выполнил студент группы 3823Б1ФИ2:** Сизов Дмитрий Игоревич  
**Работу проверили:** преподаватель Нестеров Александр Юрьевич и преподаватель Оболенский Арсений Андреевич  

## Введение  
В рамках данной работы реализован алгоритм подсчета несовпадающих символов в двух строках одинаковой длины, а также выполнена его параллелизация с использованием технологии MPI. Целью является ускорение вычислений за счет распределения работы между несколькими процессами.

## Постановка задачи и формальное описание  
Имеются две строки одинаковой длины. Требуется определить количество позиций, на которых символы в строках различаются.  
Формально: пусть `A` и `B` — строки длины `n`. Необходимо вычислить:  
`count = количество таких i, что A[i] ≠ B[i] для 0 ≤ i < n`

## Пример  
Строка A: `"abcde"`  
Строка B: `"abzdf"`  
Несовпадения: 2 (позиции 2 и 4)

## Реализация разделена на модули  
- `ops_seq.hpp` и `ops_seq.cpp` — реализация последовательного алгоритма  
- `ops_mpi.hpp` и `ops_mpi.cpp` — реализация параллельного алгоритма  
- `common.hpp` — общее определение входных/выходных типов  

## Описание последовательной версии  
Алгоритм проходит по всем символам строк и сравнивает их попарно. Каждое несовпадение увеличивает счетчик. Итог — общее количество отличий.

## Описание параллельной версии  
## Параллельная реализация (MPI)

**Основная идея:**  
Каждый процесс получает часть индексов для сравнения.  
Например, при `size = 4` (4 процесса) процесс с рангом `r` обрабатывает элементы с индексами `r, r + 4, r + 8, ...`.

**Пошаговая логика:**

1. Определяются ранг (`rank`) и общее число процессов (`size`).  
2. Каждый процесс подсчитывает количество несовпадений в своей подстроке.  
3. Частичные результаты собираются на процессе 0 с помощью `MPI_Reduce` (операция суммирования).  
4. Глобальный результат рассылается всем процессам через `MPI_Bcast`.  
5. Процесс 0 записывает результат в `GetOutput()`.

**Ключевой фрагмент реализации:**
```cpp
int local_result = 0;
for (int i = rank; i < total_size; i += size) {
  if (str_a_[i] != str_b_[i]) {
    ++local_result;
  }
}

MPI_Reduce(&local_result, &global_result_, 1, MPI_INT, MPI_SUM, 0, MPI_COMM_WORLD);
MPI_Bcast(&global_result_, 1, MPI_INT, 0, MPI_COMM_WORLD);
GetOutput() = global_result_;


## Тестирования разделены на модули  
- `functional/main.cpp` — функциональные тесты  
- `performance/main.cpp` — производительные тесты

## Функциональное тестирование  
Функциональные тесты предназначены для проверки корректности работы алгоритма на заранее известных входных данных.  
В рамках теста используются строки, считываемые из файла `strings.txt`. Файл содержит две строки, которые сравниваются с помощью обеих реализаций.  
Ожидаемый результат рассчитывается в рамках теста: для каждой позиции двух строк выполняется сравнение, и при обнаружении различий счётчик увеличивается.  
Результат, возвращаемый алгоритмом, сопоставляется с ожидаемым значением. Это позволяет удостовериться в корректности как последовательной, так и MPI-реализации.

## Тестирование производительности  
В тестировании на производительность формируются две строки по 1 миллиону символов.  
Первая строка полностью состоит из символов `'a'`, вторая — копия первой, но с заменой первых 10% символов на `'b'`.  
Это гарантирует строго определённое число несовпадений (100 000), что позволяет точно проверить корректность результата.