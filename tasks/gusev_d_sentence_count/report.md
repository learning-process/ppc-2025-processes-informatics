# Подсчёт числа предложений в строке
- Студент: Гусев Дмитрий Алексеевич, 3823Б1ФИ1
- Технология: SEQ, MPI 
- Вариант: 25

---

## 1. Введение
Подсчёт предложений в текстовых данных — одна из базовых задач анализа текста. Такая функциональность востребована в системах обработки естественного языка, инструментах оценки сложности текста, а также в приложениях для автоматического создания аннотаций.

В рамках данной работы разработана параллельная реализация алгоритма подсчёта предложений на базе MPI. Проведена верификация корректности работы и исследование масштабируемости решения относительно последовательной версии.

---

## 2. Постановка задачи
**Исходные данные**: произвольная текстовая строка, содержащая буквенные символы, цифры, знаки препинания и пробельные символы.

**Цель**: вычислить число предложений в данной строке.

**Определение предложения**: фрагмент текста, оканчивающийся терминатором — точкой (`.`), восклицательным (`!`) или вопросительным (`?`) знаком. Группы идущих подряд терминаторов (типа `!!!` или `...`) трактуются как окончание одного предложения.

**Вход**: строка произвольной длины.
**Выход**: целое неотрицательное число — количество предложений.

**Требования**:
- алгоритм должен обрабатывать строки значительного размера (мегабайты);
- решение должно функционировать с произвольным числом MPI-процессов;
- разбиение текста на части между процессами не должно приводить к ошибкам в подсчёте.

---

## 3. Последовательный алгоритм
Алгоритм последовательной обработки выполняет однократный проход по строке. При обнаружении терминатора проверяется, не является ли следующий символ также терминатором. Если нет (или достигнут конец строки), счётчик предложений увеличивается.

Алгоритм:
```cpp
sentence_count = 0;
for i from 0 to length(input) - 1:
	if input[i] in {'.', '!', '?'}:
		if i + 1 >= length(input) or input[i + 1] not in {'.', '!', '?'}:
			sentence_count += 1
```

Временная сложность: O(n), где n — длина входной строки.

---

## 4. Параллельная схема
- **Разделение данных**:
	- Текст делится на равномерные сегменты, количество которых равно числу процессов.
	- Распределение сегментов выполняется посредством `MPI_Scatterv`.
	- Для корректной обработки границ каждому процессу передаётся один дополнительный символ из следующего сегмента.
- **Локальные вычисления**:
	Процессы параллельно анализируют свои сегменты функцией `CountSentencesInChunk`, определяя терминаторы и проверяя, что за ними не следует другой терминатор.
- **Сбор результатов**:
	Локальные счётчики суммируются через `MPI_Reduce` на процессе с рангом 0.
- **Коммуникационная модель**:
	Применяется стандартный коммуникатор `MPI_COMM_WORLD` с равноправными процессами. Используются коллективные операции распределения и редукции.

---

## 5. Реализация
- **Структура проекта:**
	- `gusev_d_sentence_count/seq/include/ops_seq.hpp` и `gusev_d_sentence_count/seq/src/ops_seq.cpp` — однопоточная версия.
	- `gusev_d_sentence_count/mpi/include/ops_mpi.hpp` и `gusev_d_sentence_count/mpi/src/ops_mpi.cpp` — MPI-версия.
	- `gusev_d_sentence_count/common/include/common.hpp` — общие типы и интерфейсы.
- **Функциональность**:
	- `IsTerminator(char)` — определяет, является ли символ терминатором (`.`, `!`, `?`).
	- `CountSentencesInChunk(std::vector<char>, int)` — считает предложения в локальном сегменте процесса.
- **Реализационные детали**:
	- **Обработка пустой строки.**  
	    На старте MPI-алгоритма проверяется, не пуста ли входная строка. При пустой строке сразу возвращается `0`, что исключает лишние коммуникационные операции.
	- **Выравнивание длины строки.**  
	    Длина строки приводится к кратности числу процессов путём добавления пробелов в конец.  
	    Это упрощает равномерное распределение данных и устраняет необходимость специальной обработки последнего процесса.  
	    Расширение строки максимум на `comm_size - 1` символов практически не влияет на производительность и обычно не требует переаллокации памяти.
	- **Распределение сегментов.**  
	    Процесс получает свой блок из `chunk_size` символов плюс один символ из начала следующего блока (итого `chunk_size + 1` в буфере).  
	    Это даёт возможность корректно обработать ситуацию, когда предложение разорвано между процессами. В основном цикле обрабатываются только `chunk_size` символов, при этом для каждого найденного терминатора проверяется следующий символ:
	    ```cpp
	    if (IsTerminator(local_chunk[i])) {
			if (!IsTerminator(local_chunk[i + 1])) {
				sentence_count++;
			}
		}
	    ```
	    Такой подход обеспечивает правильный учёт групп терминаторов (например, `!!!`, `...`) как одного предложения, даже если они попадают на разные процессы.
	- **Единообразные буферы.**  
		Все процессы получают буферы одинакового размера `chunk_size + 1`, где лишний символ нужен только для проверки границы. Это делает распределение данных симметричным и упрощает код.

---

## 6. Тестовая конфигурация
- **Оборудование**: 
	Процессор: Intel(R) Core(TM) Ultra 9 185H (16 ядер, 22 логических процессора)  
	ОЗУ: 32 ГБ
- **ОС:** Windows 10 IoT Enterprise Subscription 2009
- **Компилятор:** Microsoft Visual C++ версии 19.44.35220
- **MPI:** Microsoft MPI версии 10.1.12498.18
- **Режим компиляции:** Release с оптимизацией (`/O2`)

---

## 7. Результаты экспериментов
### 7.1 Верификация
### 7.2 Измерения производительности

---

## 8. Выводы

---

## 9. Литература
- Материалы курса "Параллельное программирование"
- Справочная документация Open MPI

---

## 10. Приложение