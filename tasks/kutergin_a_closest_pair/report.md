# Нахождение наиболее близких соседних элементов вектора

- Student: Кутергин Антон Андреевич, group 3823Б1ФИ1
- Technology: SEQ | MPI 
- Variant: 7

## 1 Введение

Нужно было реализовать параллельный и последовательный алгоритм для поиска наиболее близких соседних элементов вектора

## 2 Постановка задачи

На вход подается вектор v, нужно найти такой индекс i, что велечина |v[i] - v[i+1]| минимальна среди всех пар элемента

## 3. Baseline Algorithm (Sequential)

Последовательно просматривает пары v[i], v[i+1], сравнивает разности и возвращает индекс максимума

## 4. Parallelization Scheme

Вектор разбивается на MPI процессы, корректно обрабатывая границы между процессами, чтобы последнему числу этого процесса и первому следующего процесса также образуют пару. Каждый ищет свой локальный минимум среди всех своих соседних пар. Возвращаем глобальный индекс пары с помощью MPI_Reduce

## 6. Experimental Setup

-HARDWARE/OS: CPU - Intel Core i5-8300H, cores/threads - 4/8, RAM - 12gb, OS - Ubuntu 24.04 (DevContainer / WSL 2)
TOOLCHAIN: g++ 13.3.0, build type - Release


## 7. Results and Discussion

### 7.1 Correctness

Функциональные тесты: вектор может принимать как положительные, так и отрицательные значения или содержать и положительные и отрицательные значения, так же обрабатывается случай, когда вектор пуст или у него одно значение и пару ему не найти.
MPI версия запускалась на 4 ядрах - эталонное ускорение в 4 раза.
Тест на производительность: генерация n чисел и запуск алгоритмов, чтобы узнать время выполнения.

### 7.2 Performance

| Размер данных | MPI версия (сек)       | SEQ версия (сек)        |
|---------------|------------------------|-------------------------|
| 100,000,000   | 0.2043553312           | 0.1970105648            |


## 8. Conclusions

Алгоритм нахождения наиболее близких соседних элементов вектора работает как последовательно, так и параллельно. SEQ версия чуть быстрее MPI, можно даже сказать что они равны, скорее всего это связано с тем что, задача достаточно легкая, в ней мы просто проходимся по вектору и вычисляем разницу и накладные расходы MPI процессов не сильно так сильно выигрывают. Возможно если будет больше данных и ядер, то результат измениться в пользу MPI.

## 9. References
1.Лекции по параллельному программированию
2.Практические занятия по параллельному программированию