# Умножение плотных матриц. Элементы типа double. Блочная схема, алгоритм Кэннона.

- Student: Сахаров Александр Владимирович, group 3823Б1ФИ3
- Technology: SEQ | MPI
- Variant: 1

## 1. Введение
Задача умножения плотных матриц хорошо иллюстрирует разницу между последовательной и распределённой работой с памятью. В данной работе реализовано умножение плотных матриц с 1D-раскладкой по строкам (row-wise decomposition): матрица $A$ делится между процессами, матрица $B$ целиком рассылается всем, после чего строки $C$ собираются обратно. Несмотря на название варианта задания («алгоритм Кэннона»), реализация не использует классический алгоритм Cannon с 2D-сеткой процессов и циклическими сдвигами блоков, а применяет более простую горизонтальную схему распределения.

## 2. Постановка задачи
**Формальная постановка:** для матриц $A \in \mathbb{R}^{m \times k}$ и $B \in \mathbb{R}^{k \times n}$ вычислить $C = A \times B$.

**Входные данные:**
- размеры $m, k, n$ (как `rows_a`, `cols_a`, `rows_b`, `cols_b`);
- два построчных массива `double` длиной $m\cdot k$ и $k\cdot n$.

**Выходные данные:**
- построчный массив длиной $m\cdot n$ с элементами $C$.

**Ограничения и допущения:**
- $m, k, n > 0$, выполняется $k = rows\_b$;
- размеры входных массивов равны заявленным произведениям;
- MPI-версия работает при любом числе процессов, при `world_size = 1` выполняется последовательная ветка.

## 3. Последовательная версия
SEQ-вариант — наивное троекратное умножение без блочного разбиения.
- **Validation:** `IsValidInput` проверяет знаки размеров, совместимость $k$ и фактическую длину массивов.
- **PreProcessing:** выделение и обнуление выходного буфера размера $m\cdot n$.
- **Run:** вложенные циклы по $(i, p, j)$ с индексацией через `Idx(cols, row, col)`; приращение $c_{ij} += a_{ip} \cdot b_{pj}$.
- **PostProcessing:** отсутствует.

## 4. Параллельная версия (MPI)

### 4.1. Распределение данных
- При `world_size = 1` вызывается тот же тройной цикл, что и в SEQ.
- Для $P > 1$ вычисляются равные пачки строк $A$: `base_rows = m / P`, первые `m mod P` рангов получают на одну строку больше. Индексы смещений (`row_displs`) формируют параметры для `MPI_Scatterv`.
- Матрица $A$ рассылается построчно через `MPI_Scatterv`, каждый ранг получает `local_rows` строк.
- Матрица $B$ перед вычислением целиком рассылается всем рангам одним `MPI_Bcast`.

### 4.2. Локальное вычисление
- Каждая нода умножает свои `local_rows \times k` на общий блок $B$ (`k \times n`) в функции `LocalMultiply`, используя вложенные циклы $(i, p, j)`.

### 4.3. Сбор и распространение результата
- Частичные строки $C$ отправляются в ранг 0 через `MPI_Gatherv` с теми же смещениями.
- Ранг 0 восстанавливает полный массив $m \times n$ и делает финальный `MPI_Bcast`, чтобы результат был доступен всем процессам (удобно для тестов).

### 4.4. Псевдокод MPI-версии

```pseudocode
RunImpl():
	rank, P = MPI_Comm_rank/size
	if P == 1:
		return naive_triple_loop

	row_counts, row_displs = split_rows(m, P)
	local_a = Scatterv(A, counts=row_counts*k)
	B_all = Bcast(B)

	local_c = zeros(local_rows * n)
	for i in 0..local_rows-1:
		for p in 0..k-1:
			a_val = local_a[i, p]
			for j in 0..n-1:
				local_c[i, j] += a_val * B_all[p, j]

	Gatherv(local_c, counts=row_counts*n, root=0)
	Bcast(full_C, root=0)
	return true
```

## 5. Детали реализации

### 5.1. Файловая структура проекта
`tasks/sakharov_a_cannon_algorithm/`:
- `common/include/common.hpp` — типы `MatrixInput`, `InType`/`OutType`, индексация `Idx`, валидатор `IsValidInput`.
- `seq/include/ops_seq.hpp`, `seq/src/ops_seq.cpp` — последовательный таск: валидация, подготовка буфера, тройной цикл.
- `mpi/include/ops_mpi.hpp`, `mpi/src/ops_mpi.cpp` — MPI-реализация со `Scatterv` строк $A$, `Bcast` матрицы $B$, локальным умножением и `Gatherv` + финальным `Bcast` результата.
- `tests/functional/main.cpp` — 8 функциональных наборов (единичные, квадратные и прямоугольные случаи), сравнение с наивным эталоном.
- `tests/performance/main.cpp` — перф-тест: $N = \max(1024, 128 \cdot P)$, конструирует детерминированные матрицы и сверяет с наивным результатом.

### 5.2. Ключевые классы и функции
- `IsValidInput` и `Idx` — базовая проверка входа и безопасная индексация.
- `SakharovACannonAlgorithmSEQ::RunImpl` — последовательный троекратный обход.
- `LocalMultiply` — локальный цикл в MPI-версии.
- `SakharovACannonAlgorithmMPI::RunImpl` — `MPI_Scatterv` строк $A$, `MPI_Bcast` $B$, тройной цикл, `MPI_Gatherv` $C$ и финальный `MPI_Bcast`.

### 5.3. Использование памяти
- **SEQ:** хранит целиком $A$, $B$, $C$; доп. память — только выходной буфер.
- **MPI:** каждый ранг держит свои строки $A$ (`local_rows \cdot k`), весь $B$ (`k \cdot n`), локальный $C$ (`local_rows \cdot n`); ранг 0 также хранит полный вывод для `Gatherv` и последующего `Bcast`.

## 6. Экспериментальное окружение

**Аппаратная платформа / ОС:**
- CPU: Intel Core i5-12400F (6 cores, 12 threads, 2.50 GHz);
- RAM: 32 GB DDR4;
- Накопитель: SSD 512 GB;
- ОС: Windows 10 + WSL (Ubuntu 24.04.3 LTS).

**Инструменты разработки:**
- Компилятор: `g++ 13.3.0`;
- MPI: `OpenMPI 4.1.6`;
- Сборка: `CMake 3.28.3`.

**Параметры запуска:**
- число процессов: 6 (`mpirun -n 6 ...`);
- размер матрицы в перф-тестах: $N = \max(1024, 128 \cdot P)$; при $P = 6$ получено $N = 1024$.

## 7. Результаты и обсуждение

### 7.1. Корректность
- Восемь функциональных кейсов: $1\times1$, $2\times2$, $3\times3$ (единичная), $4\times4$ со смешанными значениями, а также прямоугольные $2\times3 \cdot 3\times2$, $3\times2 \cdot 2\times4$, строки на столбец и столбец на строку.
- Эталон для всех кейсов считается наивным умножением, допускается погрешность $10^{-9}$.
- Валидатор входа отсекает несовместимые размеры и неверные длины массивов.

### 7.2. Производительность

| Mode | Time, s | Speedup | Efficiency |
|------|---------|---------|------------|
| seq, pipeline_sakharov_a_cannon_algorithm_seq_enabled | 0.9393100739 | 1.00 | N/A |
| mpi, pipeline_sakharov_a_cannon_algorithm_mpi_enabled | 0.1604703494 | 5.85 | 97.6% |
| seq, task_run_sakharov_a_cannon_algorithm_seq_enabled | 0.9245770931 | 1.00 | N/A |
| mpi, task_run_sakharov_a_cannon_algorithm_mpi_enabled | 0.1633694138 | 5.66 | 94.3% |

**Интерпретация:**
- Почти линейное ускорение на 6 процессах благодаря единовременной рассылке $B$ и равномерному делению строк $A$; накладные расходы на Scatterv/Gatherv минимальны при $N=1024$.
- Режим `pipeline` немного опережает `task_run`, различие укладывается в системный шум.
- Эффективность близка к 100%: коммуникации состоят из одной рассылки $B$ и двух коллективных операций по строкам $A$ и $C$.

## 8. Заключение
Реализованы SEQ и MPI-варианты умножения плотных матриц с построчной декомпозицией. MPI-версия распределяет строки $A$, транслирует $B$ и собирает результат обратно, обеспечивая почти линейное ускорение на 6 процессах. Потенциальные улучшения: блочное кеш-дружественное умножение и распределение $B$ по частям, если размер $k \cdot n$ перестанет помещаться в память каждой ноды.

## 9. Источники
1. Microsoft MPI : документация [Электронный ресурс] // Microsoft Learn. – URL: https://learn.microsoft.com/ru-ru/message-passing-interface/microsoft-mpi (дата обращения: 20.11.2025).
2. Сысоев А. В. Курс лекций по параллельному программированию