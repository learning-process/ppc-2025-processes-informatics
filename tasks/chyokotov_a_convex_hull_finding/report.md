# <Построение выпуклой оболочки для компонент бинарного изображения>

- Student: Чёкотов Алексей Павлович, группа 3823Б1ФИ2
- Technology: SEQ | MPI
- Variant: 32

## 1. Introduction
Задача поиска выпуклых оболочек компонент бинарного изображения состоит в эффективном обнаружении и описании выпуклых контуров связных компонент в крупномасштабных бинарных изображениях, обработка которых последавательной версией алгоритма становится неэффективной. Для решения этой проблемы применяется параллельная реализация алгоритма.

## 2. Problem Statement
Необходимо найти выпуклые оболочки для компонент бинарного изображения.
Входные данные: Матрица vector\<vector\<int>>
Выходные данные: Массив vector\<vector\<pair\<int,int>>>

**Ограничения**
Числовой диапазон:
 0 - фон
 1 - закрашенный пиксель
В матрице должны быть строки одинаковой длины.

## 3. Baseline Algorithm (Sequential)
1. Поиск компонент бинарного изображения
2. Для каждой компоненты нахождение всех её пикселей при помощи алгоритма поиска в ширину, где шаг это переход на 1 клетку вверх, вниз, влево или вправо(4х связность)
3. Строим выпуклую оболочку алгоритмом Эндрю по списку всех пикселей, полученных ранее.

**Работа алгоритма** 
- Сортируем все координаты по возростанию Х.
- Строим нижнюю оболочку при помощи векторного произведения, находя самую крайнюю точку.
- По такому же правилу строим верхнюю оболочку, но в обратной последовательности. 
- Удаляем дубликат первой точки и возвращаем результат. 

## 4. Parallelization Scheme
1. Рассылаем построчно данные входной матрицы с нулевого процесса в функции DistributeImageData()
2. Каждый процесс ищет компоненты бинарного изображения в своей области при помощи обхода в ширину
3. ExchangeBoundaryRows() - для обмена граничными строчками между процессами для корректной обработки компонент попавших в область нескольких процессов
4. В функциях ProcessExtendedRegion() и ExtractComponent() извлечение одной конкретной компоненты, возвращается вектор координат всех её пикселей
5. Фильтруем компоненты в FilterLocalComponents(), на процессе остаются только те компоненты, у которых минимальная Y-координата попадает в диапазон строк процесса. Так гарантируется, что каждая компонента обрябатывается только одним процессом
6. Построение выпуклых оболочек выполняется независимо на каждом процессе для компонент, находящихся в его локальной области. Для этого используется алгоритм Эндрю, который реализован последовательно в функции ConvexHullAndrew(). Алгоритм работает с помощью векторного произведения, вычисляемого функцией Cross()
7. Сбор всех оболочек на нулевом процессе GatherHullsOnRank0() и SendHullsToRank0(), прием оболочек в функции ReceiveHullsFromRank()
8. Процессы получают финальный результат в BroadcastResultToAllRanks()

## 5. Implementation Details
**Структура проекта:**
- mpi версия: tasks\chyokotov_a_convex_hull_finding\mpi\
- Последовательная версия: tasks\chyokotov_a_convex_hull_finding\seq\
- Функциональные тесты: tasks\chyokotov_a_convex_hull_finding\tests\functional\
- Производительность: tasks\chyokotov_a_convex_hull_finding\tests\performance\

**Использование MPI:**
- Для рассылки столбцов используется MPI_Scatterv()
- Обмен граничными строчками происходит с помощью MPI_Sendrecv()
- Рассылка локальных результатов происходит MPI_Send() и MPI_Recv()
- Итоговая рассылка результата MPI_Bcast()

Кроме потребления памяти на входные и выходные данные в mpi версии используются массивы для:
- Хранения части строк исходной матрицы на каждом процессе
- Граничных строк процессов
- Локальных компонент связности
- Получения результата

## 6. Experimental Setup
- CPU - AMD Ryzen 5 5500U with Radeon Graphics(2.10 GHz)
- 6 cores, 12 treads.
- OS: Windows 11, 25Н2 version
- compiler: clang version 21.1.0 build type Release
- Data: Генерация матрицы 8000*8000.

## 7. Results and Discussion

### 7.1 Correctness
Функциональные тесты для проверки на корректность:
- Матрица нулевого размера
- Матрица с одним закрашенным пикселем
- Пустая матрица 2*2
- Матрица 4*4 с двумя несвязными компонентами в углах
- Матрица 4*3 с прямоугольной компонентой в центре
- Матрица, где в шахматном порядке разбросаны единицы

### 7.2 Performance
Тест на производительность выполнялся на матрице размером 8000*8000,
включающим:
- Большой прямоугольник
- Крест
- Квадратная рамка, полая внутри
- 100 малых компонент разной формы
- 25000 пикселей, расположенных в шахматном порядке

|   Mode  | Count | Time, s | Speedup | Efficiency |
|---------|-------|---------|---------|------------|
|   seq   |   1   | 2.6438  |  1.00   |    N/A     |
|   mpi   |   2   | 2.0690  |  1.27   |   63.9%    |
|   mpi   |   4   | 1.8349  |  1.44   |   36.0%    |
|   mpi   |   6   | 1.8289  |  1.45   |   24.1%    |

На основании полученных результатов можно сделать вывод, что разработанная MPI-реализация алгоритма поиска выпуклых оболочек для крупных бинарных изображений демонстрирует неэффективное масштабирование: при использовании 2, 4 и 6 процессов наблюдается незначительное изменение по сравнению с последовательной версией, а эффективность использования вычислительных ресурсов падает, что свидетельствует о преобладании накладных расходов на коммуникацию и синхронизацию.

## 8. Conclusions
Были реализованы SEQ и MPI версии алгоритма и в результате сравнения их работы выяснилось, что решение плохо масштабируется для задачи.

## 9. References
1. [Документация OpenMPI](https://www.open-mpi.org/doc/)
2. [стандарт с++](https://www.open-std.org)