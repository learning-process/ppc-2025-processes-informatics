# Количество несовпадений символов двух строк

- Студент: Овсянников Никита Владимирович, группа 3823Б1ФИ2
- Технология: SEQ, MPI
- Вариант: 27

## 1. Introduction

Цель данной работы — научиться применять технологию MPI для распараллеливания задач. В качестве примера выбрана задача сравнения двух строк. Хотя сама по себе задача простая, на ней удобно разбирать, как делить данные между процессами и собирать общий результат.

## 2. Problem Statement

У нас есть две строки одинаковой длины. Нужно пройтись по ним и посчитать, сколько раз символы на одной и той же позиции не совпадают.

**Входные данные:** Две строки (`std::string`).
**Выходные данные:** Целое число — количество несовпадений.

## 3. Baseline Algorithm (Sequential)

В последовательной версии мы просто бежим циклом от начала до конца строки.

```cpp
int mismatch_count = 0;
size_t n = seq_one.size();
for (size_t i = 0; i < n; ++i) {
    if (seq_one[i] != seq_two[i]) {
        mismatch_count++;
    }
}
```
Сложность линейная - O(N).

## 4. Parallelization Scheme
Процесс с рангом 0 определяет размер данных. Исходные строки делятся на части по количеству процессов. Ранг 0 рассылает каждому процессу его куски двух строк (используется Scatterv). Каждый процесс независимо сравнивает символы в полученных частях. Локальные счетчики несовпадений суммируются в общий результат (Allreduce).

## 5. Implementation Details
- common: Определяет общие типы данных.
- seq: Последовательная реализация (обычный цикл).
- mpi: Параллельная реализация. Использует векторы для упаковки данных перед отправкой.
- tests: Тесты на корректность (разные случаи несовпадений) и на скорость.

## 6. Experimental Setup
- Аппаратное обеспечение: 13th Gen Intel Core i5-13500H (12 ядер: 4P + 8E, 2.60 GHz)
- ОЗУ: 16 ГБ (4266 MT/s)
- Операционная система: Windows 11
- Компилятор: MinGW-w64 (g++)
- Тип сборки: Release

## 7. Results and Discussion

### 7.1 Correctness
Корректность проверялась на пустых строках, полностью одинаковых, полностью разных и со случайными несовпадениями. Результаты MPI версии совпадают с последовательной.

### 7.2 Performance

Тест на строках длиной 10 000 000 символов:

| Mode        | Count | Time, s | Speedup | Efficiency |
|-------------|-------|---------|---------|------------|
| seq         | 1     | 0.0065  | 1.00    | 100%       |
| mpi         | 2     | 0.0146  | 0.45    | 22.5%      |
| mpi         | 4     | 0.0137  | 0.47    | 11.8%      |
| mpi         | 8     | 0.0143  | 0.45    | 5.6%       |
| mpi         | 12    | 0.0172  | 0.38    | 3.2%       |
| mpi         | 24    | 0.0303  | 0.21    | 0.9%       |
| mpi         | 48    | 0.0769  | 0.08    | 0.2%       |

## 8. Conclusions
- **MPI работает медленнее SEQ:** На всех тестах параллельная версия уступает последовательной. Это связано с тем, что операция сравнения символов выполняется мгновенно. Время тратится не на полезную работу, а на копирование памяти и передачу данных между процессами (`Scatterv`).
- **Стабильность (2-8 процессов):** При малом числе процессов время выполнения примерно одинаковое (около 0.014 с). Это тот минимум времени, который нужен MPI для инициализации и пересылки данных.
- **Замедление (12+ процессов):** При увеличении числа процессов время начинает расти.
- **Перегрузка (24-48 процессов):** Наблюдается резкое падение производительности (в 10 раз медленнее SEQ). Это объясняется тем, что количество процессов превышает количество физических ядер процессора (12 ядер). Операционная система тратит ресурсы на переключение контекста между процессами.

## 9. References
1. Лекции и практики курса "Параллельное программирование".