#  Сумма элементов вектора

- Студент: Курпяков Алексей Георгиевич, 3823Б1ФИ3   
- Технологии: SEQ | MPI 
- Вариант: 1

## 1. Введение
В рамках данной работы был реализован алгоритм суммирования элементов вектора: последовательна и параллельная реализация. 

## 2. Постановка задачи
Дан вектор v из N элементов. Необходимо найти найти сумму всех его элементов.
Рассмотрим элементы v = {1, 2, 3 ... N}
Решением задачи будет нахождения суммы: sum = v[0] + v[1] + ... + v[N - 1]

## 3. Описание линейного алгоритма

Последовательная версия:
проходимся по всему массиву, собираем префикс сумму по нему. 


## 4. Описание схемы параллельного алгоритма
Пусть у нас K процессов, вектор размера N, тогда алгоритм такой:
Процессы делят массив на M частей. 
Части выделяются следующим образом:
Сначала считаем минимум, который будет каждый процесс обрабатывать:
batch = N/K  
Затем вычисляем остаток от деления:
remainder = M % N
Первые remainder процессов заберут по 1 элементу из массива, остальные отработают только свой пакет.
Затем 0-ой процесс рассылает каждому потоку свой участок памяти и его размер остальным процессам.
После того как каждый процесс отработал свой участок и посчитал сумму внутри своего вектора 0-ой процесс собрает результаты и суммирует их.

## 5. Окружение
- Hardware/OS: CPU - AMD Rizen 7 7840HS, cores - 8, RAM - 16GB, Ubuntu 24 on WSL
- Toolchain: GCC 13, Release
- Environment: PPC_NUM_PROC = 8
- Data: |v| = 10000000, v[i] = i

## 6. Результаты экспериментов и выводы

Функциональные тесты содержат 9 тестов:
 - Тест1: пустой вектор
 - Тест2: одиночный элемент
 - Тест3: положительные числа в векторе 
 - Тест4: вектор состоящий из нулей
 - Тест5: значения с разными знаками
 - Тест6: значения граничащие с переполнением типа int
 - Тест7: переполнение типа int
 - Тест8: только отрицательные числа
 - Тест9: вектор четной длины, такой что для любого v[i] существует v[j] = -v[i] (i != j)

Тест на производительность - |v| = {5000000, 7500000 10000000}, v[i] = i

Ниже таблица с результатами Perf тестов.

В таблице представлено: n - размер вектора, время выполнения SEQ и MPI версии для 4-х процессов (в милисекундах):

| Размер данных (n) | SEQ версия (ms)| MPI версия (ms) | Ускорение |
|-------------------|----------------|------------------|----------|
| 5 000 000         | 96             | 114              | 0,84     |
| 7 500 000         | 173,5          | 183              | 0,94     |
| 10 000 000        | 372            | 219              | 1,69     |

*результат был получен при запуске build/bin/ppc_perf_tests*

При замерах была получена данная таблица.
Мнjю не было получено ожидаемое ускорение в 8 раз. 
Это нормально, так как чтобы появился рабочий процесс нужно выполнить команду операционной системы для его создания, что занимает много времени в масштабах задачи суммирования элементов вектора.  
Операция суммирования отлично векторизуется и выполняется за 1 тик процессора на современных процессорах с архитектурой x86.Так же много времени забирает операция раздачи элементов вектора каждому процессу и рассчет смещений и размеров пераедаваемых пакетов. Поэтому ожидаемо что прирост скорости начнет проявлятся при действительно больших данных.

## 7. Заключение
В результате проделанной работы были реализованы версии MPI, SEQ алгоритма нахождения суммы элементов вектора.
Было так же показано, что MPI версия работает быстрее SEQ при больших данных, а при небольших - наоборот.


## Источники
1. [cppreference.com](https://en.cppreference.com/)
2. [стандарт с++](https://www.open-std.org)
3. [Документация OpenMPI](https://www.open-mpi.org/doc/)
