# Интегрирование – метод прямоугольников

- Студент: Романов Артем Сергеевич, группа 3823Б1ФИ3
- Технологии: SEQ | MPI
- Вариант: 19 

## 1. Введение
Интегрирование функций является составной частью многих научных и технических задач. Поскольку аналитическое интегрирование не всегда возможно, часто используются различные методы численного интегрирования. Метод прямоугольников является одним из наиболее простых для понимания и реализации методов, идея которого заключается в приближении значения интеграла некоторой интегральной суммой.

Целью данной работы является реализация последовательной и параллельной версии алгоритма численного вычисления значения интеграла методом прямоугольников, а также исследования эффективности их работы.

## 2. Постановка задачи
Пусть задана функция $f(x): \mathbb{R} \to \mathbb{R},$ которая  интегрируема на заданном отрезке $[a,b]$. Требуется приближённо вычислить значение определённого интеграла

$I = \int\limits_a^b f(x)dx$

с помощью метода прямоугольников.

Входными данными являются функция $f(x): \mathbb{R} \to \mathbb{R}$, вещественные границы отрезка интегрирования $a, b$  $(a < b)$, на котором функция определена, и натуральное число слагаемых $n$ в интегральной сумме.


## 3. Базовый алгоритм (последовательный)
Метод прямоугольников заключается приближении значения определённого интеграла с помощью интегральной суммы:

$\int_{a}^{b} f(x) dx \approx \sum_{i=1}^{n} f(x_{i}^{\*}) \cdot \Delta x_{i}$,где  $x_{i}^{\*} \in [x_{i-1}, x_{i}]$ и $\Delta x_i = x_i - x_{i-1}$

Все $\Delta x_i$ полагаются равными $\frac{b-a}{n}$, где $n$ - число элементарных отрезков, а $x_i^*$ выбирается по-разному в зависимости от варианта метода прямоугольников. Основных вариаций три:
1. **Метод левых прямоугольников** - используется значение функции в левой границе каждого элементарного отрезка: $x_i^* = x_{i-1}$;  
2. **Метод правых прямоугольников** - используется значение функции в правой границе каждого элементарного отрезка: $x_i^* = x_{i}$;  
3. **Метод средних прямоугольников** - используется значение функции в середине каждого элементарного отрезка: $x_i^* = \frac{x_{i-1} + x_{i}}{2}$.  

В данной работе реализуется метод средних прямоугольников.

Последовательный алгоритм реализует описанный выше способ вычисления и может быть представлен следующим псевдокодом:

```python
  delta_x = (b - a) / n;
  mid = a + (delta_x / 2);
  result = 0.0;
  for (i = 0; i < n; i += 1) {
    result += f(mid) * delta_x;
    mid += delta_x;
  }
```
## 4. Схема параллелизации
Вычисления в параллельном алгоритме организованы схожим образом: каждый процесс вычисляет значение интеграла на некотором подотрезке номеров слагаемых интегральной суммы.

Изначально каждый процесс получает свой ранг и общее число процессов:
```cpp
  int rank = 0;
  MPI_Comm_rank(MPI_COMM_WORLD, &rank);
  
  int num_processes = 0;
  MPI_Comm_size(MPI_COMM_WORLD, &num_processes);
```

На основе этих данных вычисляются левые и правые границы номеров слагаемых:
```cpp
  int block_size = (n + num_processes - 1) / num_processes;
  int left_border = rank * block_size;
  int right_border = std::min(n, (rank + 1) * block_size);
```

После этого схожий с последовательной версией цикл считает значение интеграла на подотрезке:
```cpp
  double current_result = 0.0;
  for (int i = left_border; i < right_border; ++i) {
    current_result += f(mid) * delta_x;
    mid += delta_x;
  }
```

Затем итоговые значения суммируются и рассылаются по всем процессам:
```cpp
  double result = 0.0;
  MPI_Allreduce(&current_result, &result, 1, MPI_DOUBLE, MPI_SUM, MPI_COMM_WORLD);
  GetOutput() = result;
```


## 5. Детали реализации
- Code structure (files, key classes/functions)
- Important assumptions and corner cases
- Memory usage considerations

## 6. Условия проведения экспериментов
- Hardware/OS: Intel Core i5-10400f, 6 ядер и 12 потоков, 32GB RAM, Ubuntu 24.04.2 - Docker (запущенный на Windows 10);
- Toolchain: GCC 13.3.0, C++ with Release build type
- Environment: PPC_NUM_THREADS / PPC_NUM_PROC, other relevant vars
- Data: how test data is generated or sourced (relative paths)

## 7. Результаты

### 7.1 Корректность
Briefly explain how correctness was verified (reference results, invariants, unit tests).

### 7.2 Эффективность
Present time, speedup and efficiency. Example table:

| Mode | Count | Time, s | Speedup | Efficiency |
| ---- | ----- | ------- | ------- | ---------- |
| SEQ  | 1     | 1.321   | 1.00    | N/A        |
| OMP  | 2     | 0.687   | 1.92    | 96.0%      |
| OMP  | 4     | 0.398   | 3.31    | 82.8%      |
| OMP  | 6     | 0.261   | 5.06    | 84.3%      |
| OMP  | 8     | 0.212   | 6.23    | 77.9%      |
| OMP  | 10    | 0.161   | 8.20    | 82.0%      |
| OMP  | 12    | 0.181   | 7.29    | 60.8%      |
| OMP  | 15    | 0.313   | 4.22    | 28.1%      |
| OMP  | 18    | 0.257   | 5.14    | 28.6%      |
| OMP  | 24    | 0.227   | 5.81    | 24.2%      |

Optionally add plots (use relative paths), and discuss bottlenecks and scalability limits.

## 8. Заключение
Summarize findings and limitations.

## 9. Список литературы
1. Павлова Т. Ю. Численное интегрирование [Электронный ресурс]. – Кемерово: Кемеровский государственный университет, Институт фундаментальных наук. – Режим доступа: https://ifn.kemsu.ru/page_teachers/pavlova/Numerical_integration.Brief_theory.pdf (дата обращения: 12.11.2025);
2. Оболенский А., Нестеров А. Parallel Programming course. MPI (detailed API overview) [Электронный ресурс]. – Нижегородский государственный университет. – Режим доступа: https://learning-process.github.io/parallel_programming_slides/slides/03-mpi-api.pdf (дата обращения: 18.11.2025);
3. Оболенский А., Нестеров А. Parallel Programming course. Introduction [Электронный ресурс]. – Нижегородский государственный университет. – Режим доступа: https://learning-process.github.io/parallel_programming_slides/slides/01-intro.pdf (дата обращения: 18.11.2025).