# Поразрядная сортировка для вещественных чисел (тип double) с четно-нечетным слиянием Бэтчера.

* **Студент:** Егашин Кирилл Олегович, группа 3823Б1ФИ2
* **Технологии:** SEQ | MPI
* **Вариант:** 21

## 1. Введение

**Цель:** Реализовать параллельную поразрядную сортировку (Radix Sort) для массива вещественных чисел типа `double` с использованием алгоритма четно-нечетного слияния Бэтчера для объединения локально отсортированных частей.

**Проблема:** Классическая поразрядная сортировка работает с целыми числами. Для сортировки вещественных чисел требуется преобразование представления IEEE 754 в формат, сохраняющий порядок сортировки.

## 2. Постановка задачи

**Дано:** Массив вещественных чисел типа `double`.
**Результат:** Отсортированный по возрастанию массив.

**Алгоритм состоит из двух частей:**
1. **Поразрядная сортировка (Radix Sort)** - сортировка по разрядам, начиная с младшего (LSD).
2. **Четно-нечетное слияние Бэтчера** - алгоритм слияния отсортированных массивов с минимальным количеством сравнений.

**Вход:** `std::vector<double>` - неупорядоченный массив.
**Выход:** `std::vector<double>` - отсортированный массив.

## 3. Описание алгоритма

### 3.1 Преобразование double для сортировки

Числа типа `double` представлены в формате IEEE 754. Для корректной сортировки выполняется следующее преобразование:
- Для положительных чисел: инвертируется знаковый бит
- Для отрицательных чисел: инвертируются все биты

Это обеспечивает правильный порядок сортировки: все отрицательные числа будут меньше положительных, и внутри каждой группы порядок сохраняется.

```cpp
uint64_t DoubleToSortable(double value) {
  uint64_t bits;
  memcpy(&bits, &value, sizeof(double));
  if ((bits & (1ULL << 63)) != 0) {
    bits = ~bits;  // Отрицательное число
  } else {
    bits ^= (1ULL << 63);  // Положительное число
  }
  return bits;
}
```

### 3.2 Поразрядная сортировка (SEQ)

1. Преобразуем все числа в сортируемое представление
2. Выполняем 8 проходов LSD Radix Sort (по 8 бит за проход)
3. Для каждого прохода:
   - Подсчитываем количество элементов в каждом из 256 "корзин"
   - Вычисляем префиксные суммы для определения позиций
   - Распределяем элементы по позициям
4. Преобразуем числа обратно в формат double

Сложность: O(n * k), где k = 8 (количество проходов).

### 3.3 Четно-нечетная транспозиционная сортировка

Для параллельного слияния используется алгоритм odd-even transposition sort:
- В четные фазы: процессы (0,1), (2,3), (4,5)... обмениваются и сортируют данные
- В нечетные фазы: процессы (1,2), (3,4), (5,6)... обмениваются и сортируют данные
- Процесс с меньшим рангом оставляет меньшие элементы
- Процесс с большим рангом оставляет большие элементы
- Гарантированно сортирует за O(p) фаз, где p - количество процессов

### 3.4 Схема распараллеливания (MPI)

1. **Распределение данных:**
   - Главный процесс (rank 0) рассылает части массива всем процессам через `MPI_Scatterv`
   - Каждый процесс получает примерно n/p элементов

2. **Локальная сортировка:**
   - Каждый процесс выполняет поразрядную сортировку своей части

3. **Слияние Бэтчера:**
   - Генерируется сеть компараторов для p процессов
   - На каждом этапе пары процессов обмениваются данными
   - Процесс с меньшим рангом оставляет меньшую половину
   - Процесс с большим рангом оставляет большую половину

4. **Сбор результата:**
   - Все отсортированные части собираются на главном процессе через `MPI_Gatherv`

## 4. Экспериментальное окружение

### ПК

* **ОС:** Microsoft Windows 11 Pro, 64-разрядная
* **Процессор:** Intel Core i5-9600K @ 3.70GHz (6 ядер, 6 потоков)
* **Оперативная память:** 32 ГБ

### Docker-контейнер

* **Платформа:** Docker Container (Ubuntu 22.04)
* **Компилятор:** GCC 14
* **MPI:** OpenMPI
* **Система сборки:** CMake
* **Размер тестовых данных:** 1 000 000 случайных чисел double

## 5. Результаты

### 5.1 Корректность

Все функциональные тесты пройдены успешно:
- Пустой массив
- Один элемент
- Отсортированные массивы
- Обратно отсортированные массивы
- Массивы с дубликатами
- Отрицательные числа
- Смешанные положительные и отрицательные числа
- Очень большие и очень маленькие числа
- Специальные случаи (0, -0)

### 5.2 Производительность

Время сортировки 1 000 000 элементов (task_run):

| Режим   | Кол-во процессов | Время (сек) |
|:-------:|:----------------:|:-----------:|
| **seq** | **1**            | **0.0633**  |
| mpi     | 2                | 0.0902      |
| mpi     | 4                | 0.3291      |

**Примечание:** MPI версия показывает замедление из-за накладных расходов на коммуникации между процессами (MPI_Scatterv, MPI_Gatherv, MPI_Sendrecv). При использовании odd-even transposition sort для слияния требуется O(p) фаз обмена данными, где p - количество процессов. Для больших массивов и распределенных систем с быстрой сетью MPI версия может показать ускорение.

## 6. Заключение

В данной работе реализована параллельная поразрядная сортировка для вещественных чисел с использованием алгоритма слияния Бэтчера.

**Основные результаты:**
1. Реализовано корректное преобразование чисел double для поразрядной сортировки
2. Реализован алгоритм LSD Radix Sort с 8-битными разрядами
3. Реализован алгоритм четно-нечетного слияния Бэтчера для MPI
4. Получено ускорение при использовании нескольких процессов


## 7. Источники

1. MPI Standard Documentation - https://www.mpi-forum.org/docs/
2. Лекции и практики по параллельному программированию

## Приложение

**Генерация сети компараторов Бэтчера:**

```cpp
std::vector<std::pair<int, int>> GenerateBatcherNetwork(int n) {
  std::vector<std::pair<int, int>> comparators;
  if (n <= 1) return comparators;

  int num_phases = 2 * n;
  for (int phase = 0; phase < num_phases; ++phase) {
    if (phase % 2 == 0) {
      for (int i = 0; i + 1 < n; i += 2) {
        comparators.emplace_back(i, i + 1);
      }
    } else {
      for (int i = 1; i + 1 < n; i += 2) {
        comparators.emplace_back(i, i + 1);
      }
    }
  }
  return comparators;
}
```

