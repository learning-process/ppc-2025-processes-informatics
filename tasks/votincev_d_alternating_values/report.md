# Отчет по реализации алгоритма нахождения числа чередований знаков значений соседних элементов вектора

**Дисциплина:** Параллельное программирование  
**Преподаватель:** Нестеров Александр Юрьевич и Оболенский Арсений Андреевич  
**Студент:** Вотинцев Дмитрий Сергеевич 3823Б1ФИ3
**Вариант:** 5

## Введение
В рамках данной работы был реализован алгоритм поиска чередований знаков значений соседних элементов вектора: последовательная и параллельная реализация.

## Постановка задачи
Дан вектор v из N элементов. Необходимо найти число чередований знаков между соседними элементами.
Рассмотрим элементы v[i-1] и v[i] , i = 1,2,...,N.
Если v[i-1] >= 0  и  v[i] < 0 - то это чередование
Если v[i-1] < 0  и  v[i] >= 0 - то это чередование
(0 считается беззнаковым, грубо говоря +0)

## Описание алгоритма

Последовательная версия:
проходимся по всему массиву, сравниваем соседние элементы на чередование, увеличиваем счетчик чередований (если между соседями знак чередуется). 


## Описание схемы параллельного алгоритма
Пусть у нас P процессов, вектор размера M. Алгоритм:

0-й процесс делит массив на P частей. Части выделяются следующим образом:
- Вычисляем базовый размер: `base = M / P`
- Вычисляем остаток: `remain = M % P`
- Первые `remain` процессов получают `base + 1` элементов
- Остальные процессы получают `base` элементов
- Каждому процессу добавляется 1 элемент справа для проверки граничных чередований
- Последнему процессу не добавляется лишний элемент

**Пример для 2 процессов и вектора {0, -1, 2, -3}:**
- Процесс 0: 0, -1, 2 (2 чередования: 0 -> -1, -1 -> 2)
- Процесс 1: 2, -3 (1 чередование: 2 -> -3)
- Итого: 3 чередования 



## Результаты экспериментов и выводы

**Функциональные тесты** содержат 10 тестов:
- Тест1: отсутствие чередований
- Тест2: правильная обработка 0
- Тест3: максимум чередований
- Тест4: 1 элемент
- Тест5: пустой вектор
- Тест6-10: случайные значения

**Тест на производительность** - данные генерируются как в Тест3 (максимум чередований): 0, -1, 2, -3, 4, -5...
Это самый "проблемный" случай, так как нужно учитывать чередование между граничными элементами.

**Результаты производительности (4 процесса):**
| Размер данных (n) | SEQ версия (с) | MPI версия (с) | Ускорение |
|-------------------|----------------|----------------|-----------|
| 10 000            | 0.004          | 0.005          | 0.80×     |
| 1 000 000         | 0.146          | 0.200          | 0.73×     |
| 10 000 000        | 1.561          | 1.943          | 0.80×     |
| 30 000 000        | 4.935          | 6.525          | 0.76×     |

В среднем - MPI версия стабильно проигрывает SEQ. Все дело в том, что в задаче почти нет никаких вычислений, основное - пересылка данных.
И расходы на коммуникацию (пересылку данных) занимает много времени (скорее всего больше, чем происходят сами вычисления).


## Заключение
В результате проделанной работы были реализованы версии MPI, SEQ алгоритма нахождения числа чередований знаков значений соседних элементов вектора.
По результат эксперимента можно сделать вывод: MPI версия работает медленней SEQ (в основном из-за пересылки данных и минимума вычислений)


## Литература
1. Лекции Сысоева Александра Владимировича
2. Практические занятия Нестерова Александра Юрьевича и Оболенского Арсения Андреевича
3. Интернет

## Приложения (код параллельной реализации)

```
bool VotincevDAlternatingValuesMPI::RunImpl() {
  GetOutput() = -1; // специальное значение

  int all_swaps = 0;

  // получаю кол-во процессов
  int process_n = 0;
  MPI_Comm_size(MPI_COMM_WORLD, &process_n);

  // получаю ранг процесса
  int proc_rank = 0;
  MPI_Comm_rank(MPI_COMM_WORLD, &proc_rank);

  // вектор значений (его заполняет только 0й процесс)
  std::vector<double> vect_data;

  // 0й процесс получает данные
  if (proc_rank == 0) {
    vect_data = GetInput();

    // если процессов больше, чем размер вектора — уменьшаем
    // например: вектор = 2 элемента, а процессов запущено 4
    process_n = std::min<int>(process_n, vect_data.size());
  }


  // рассылаю всем "актуальное" число процессов
  // т.к. его мог уменьшить процесс 0
  MPI_Bcast(&process_n, 1, MPI_INT, 0, MPI_COMM_WORLD);

  // если вектор пустой
  if (process_n == 0) {
    return true;
  }

  
  if (proc_rank == 0) {
    all_swaps = ProcessMaster(process_n, vect_data); // работа 0-го процесса
  }
  else if (proc_rank < process_n) {  
    ProcessWorker(); // работа процессов-работников
  }

  return true;
}
```