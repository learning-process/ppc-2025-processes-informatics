# Поразрядная сортировка для вещественных чисел (тип double) с простым слиянием.

* Студент: Розенберг Алексей Светославович, группа 3823Б1ФИ2
* Технология: SEQ | MPI
* Вариант: 20

## 1. Введение

В данной работе рассматривается задача реализации алгоритма поразрядной сортировки (Radix Sort) для вещественных чисел с плавающей точкой двойной точности.
Цель — реализовать последовательное и параллельное (MPI) решения, обеспечить корректную сортировку отрицательных и положительных чисел и исследовать эффективность алгоритма с простым слиянием.

Поразрядная сортировка является эффективным алгоритмом, работающим за линейное время относительно количества элементов. Параллелизация данного алгоритма позволяет обрабатывать массивы сверхбольших объемов, распределяя вычислительную нагрузку поразрядного анализа между процессами.

## 2. Постановка задачи

Дан одномерный массив $A$ размера $N$ элементов типа `double`.

Требуется отсортировать массив по возрастанию. Особенности задачи:

* Использование алгоритма LSD (Least Significant Digit) Radix Sort.
* Корректная обработка специфики представления вещественных чисел (IEEE 754).
* В параллельной версии — использование схемы простого слияния.

Результат должен представлять собой полностью отсортированный массив на процессе с рангом 0.

## 3. Описание алгоритма (Последовательный)

Последовательный алгоритм поразрядной сортировки для `double` выполняется в несколько этапов:

1. **Битовое преобразование:** Поскольку структура `double` не позволяет напрямую применять поразрядную сортировку (из-за знакового бита и специфики порядка), каждое число интерпретируется как `uint64_t` и трансформируется:
* Если число отрицательное, все его биты инвертируются.
* Если число положительное, инвертируется только знаковый бит.

2. **Распределение по байтам:** Выполняется 8 итераций (для 64 бит). На каждой итерации:
* Подсчитывается количество вхождений каждого значения байта (0–255).
* Вычисляются префиксные суммы для определения позиций элементов.
* Элементы переносятся в промежуточный буфер, сохраняя стабильность сортировки.

3. **Обратное копирование:** Данные из буфера возвращаются в основной массив для следующего разряда.

Асимптотическая сложность: $O(8 \times N)$, что эквивалентно $O(N)$.

## 4. Схема распараллеливания

### MPI-вариант

Реализуется через распределение данных и логарифмическое слияние:

1. **Разбиение данных:**
* Входной массив распределяется между процессами с помощью `MPI_Scatterv`.
* Каждый процесс получает блок размером приблизительно $N/P$.

2. **Локальная сортировка:**
* Каждый процесс независимо выполняет `RadixSort` над своим локальным вектором.

3. **Слияние (Merge):**
* Процессы объединяются в пары на каждом шаге.
* Один процесс в паре отправляет отсортированные данные соседу, после чего завершает работу.
* Принимающий процесс сливает свой массив и полученный массив в один упорядоченный список.

4. **Завершение:** На финальном этапе процесс `rank 0` содержит полностью отсортированный массив.

## 5. Детали имплементации

### Структура проекта

* Представление данных: `std::vector<double>`.
* Битовое кодирование: использование `std::memcpy` для безопасного копирования `double` в `uint64_t`.
* Слияние: использование `std::ranges::merge` (C++20) или ручного алгоритма двух указателей для объединения отсортированных последовательностей.
* MPI: использование `MPI_DOUBLE` для передачи вещественных чисел.

### Пограничные случаи

* Пустой массив или массив из одного элемента.
* Массив, содержащий только отрицательные или только положительные числа.
* Наличие дубликатов и значений `-0.0` и `0.0`.
* Количество процессов больше, чем количество элементов в массиве.

## 6. Экспериментальное окружение

* **Аппаратное обеспечение/ОС**: AMD Ryzen 7 7800X3D, 8 cores/16 threads, RAM 32 GB 6000 MHz, Windows 11 Home
* **Toolchain**: MSVC v143, Release (поддержка C++20)
* **Настройки окружения**: PPC_NUM_THREADS 16 / PPC_NUM_PROC 8
* **Данные**: 
    - **Эксперимент 1**: вектор `double` размером 1000000 элементов, элементы сгенерированы случайным образом на отрезке $(-10^8, 10^8)$.
    - **Эксперимент 2**: вектор `double` размером 10000000 элементов, элементы сгенерированы случайным образом на отрезке $(\frac{-2^{31}}{1\mathrm{e}{-15}}, \frac{2^{31}}{1\mathrm{e}{-15}})$

## 7. Экспериментальные результаты

### 7.1 Корректность

Корректность проверялась следующими методами:

* Сравнение результата с эталонной сортировкой (`sorted` в Python).
* Тесты на массивах с обратным порядком и случайных данных.
* Проверка сохранения всех элементов входного массива в выходном.

Все проверки успешно пройдены.

### 7.2 Производительность

#### Эксперимент 1:

| Mode        | Count | Time, s      | Speedup | Efficiency |
|-------------|-------|--------------|---------|------------|
| seq         | 1     | 0.03370352   | 1.00    | N/A        |
| mpi         | 2     | 0.02508142   | 1.34    | 67.2%      |
| mpi         | 4     | 0.02036076   | 1.66    | 41.4%      |
| mpi         | 8     | 0.01912484   | 1.76    | 22.0%      |
| mpi         | 16    | 0.01835212   | 1.84    | 11.5%      |

#### Эксперимент 2:

| Mode        | Count | Time, s      | Speedup | Efficiency |
|-------------|-------|--------------|---------|------------|
| seq         | 1     | 0.33750422   | 1.00    | N/A        |
| mpi         | 2     | 0.24701780   | 1.37    | 68.3%      |
| mpi         | 4     | 0.20227414   | 1.67    | 41.7%      |
| mpi         | 8     | 0.18577652   | 1.82    | 22.7%      |
| mpi         | 16    | 0.18974272   | 1.78    | 11.1%      |

## 8. Выводы

В ходе работы была реализована параллельная версия поразрядной сортировки (Radix Sort) для вещественных чисел с использованием простого слияния. Анализ результатов позволяет сделать следующие выводы:

* **Низкая эффективность масштабирования:** При увеличении числа процессов в 16 раз общее ускорение составило всего 1.84x, а эффективность упала с 67.2% до 11.5%. Это свидетельствует о том, что для данного объема данных накладные расходы на параллелизацию сопоставимы с полезной вычислительной работой.
* **Доминирование коммуникационных затрат:** Поразрядная сортировка обладает линейной сложностью $O(N)$ и является крайне быстрым алгоритмом. В связи с этим время, затрачиваемое на пересылку данных между узлами (`MPI_Send`/`MPI_Recv`) и синхронизацию процессов, начинает преобладать над временем самой сортировки.
* **Особенности слияния:** Использование схемы со слиянием приводит к тому, что на верхних уровнях слияния объем пересылаемых данных увеличивается, в то время как количество активно работающих процессов уменьшается. Это создает «бутылочное горлышко» (bottleneck), ограничивающее итоговый Speedup.
* **Зависимость от объема данных:** С увеличением объема данных в массиве и увеличением диапозона допустимых значений, эффективность алгоритма не изменилась.

## 9. Источники

1. [Microsoft MPI Reference](https://learn.microsoft.com/en-us/message-passing-interface/mpi-reference)
2. [C++ Reference (std::ranges::merge)](https://en.cppreference.com/w/cpp/algorithm/ranges/merge)
3. [Python Documentation](https://docs.python.org/3/index.html)
4. [Документация по курсу «Параллельное программирование»](https://learning-process.github.io/parallel_programming_course/ru/index.html)
5. Документация по курсу «Параллельное программирование», ННГУ.