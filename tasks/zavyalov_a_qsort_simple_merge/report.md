# Быстрая сортировка с простым слиянием

- Student: Завьялов Алексей Алексеевич, group 3823Б1ФИ3
- Technology: SEQ | MPI
- Variant: 14 

## 1. Introduction

Сортировка является одной из фундаментальных задач алгоритмики и широко применяется при обработке больших массивов данных. В условиях параллельных вычислений особый интерес представляют алгоритмы сортировки, допускающие эффективное распределение вычислений между несколькими процессами.

Целью данной работы является реализация последовательной и параллельной версий алгоритма быстрой сортировки с последующим простым слиянием отсортированных блоков, а также сравнение их корректности и производительности.

В параллельной версии используется распределение исходного массива между процессами, локальная сортировка каждого блока и последующее поэтапное слияние частичных результатов на корневом процессе.

## 2. Problem Statement

Требуется отсортировать одномерный массив вещественных чисел
типа `double` по возрастанию.

Последовательная версия должна выполнять сортировку всего массива
на одном процессе.

Параллельная версия должна:
 - Распределить исходный массив между процессами;
 - Выполнить локальную сортировку на каждом процессе;
 - Собрать частично отсортированные подмассивы на корневом
   процессе;
 - Выполнить простое последовательное слияние полученных отсортированных блоков.

### Входные данные

 - массив вещественных чисел типа double;
 - размер массива.

### Выходные данные

 - отсортированный массив вещественных чисел.

## 3. Baseline Algorithm (Sequential)

В последовательной версии используется реализация быстрой сортировки, выполненная в нерекурсивном виде с применением собственного стека диапазонов.

Алгоритм основан на выборе опорного элемента, разбиении массива на подмассивы относительно опорного значения и последующей обработке полученных диапазонов до полной сортировки массива.

## 4. Parallelization Scheme

Параллельная версия алгоритма реализована с использованием библиотеки MPI и включает следующие этапы:

1. Корневой процесс определяет размеры блоков и распределяет части исходного массива между процессами с помощью `MPI_Scatterv`.

2. Каждый процесс выполняет локальную сортировку полученного блока данных с использованием той же реализации быстрой сортировки, что и в последовательной версии.

3. После завершения локальной сортировки результаты собираются на корневом процессе с помощью `MPI_Gatherv`.

4. Корневой процесс выполняет поэтапное слияние отсортированных подмассивов с использованием функции `std::inplace_merge`.

## 5. Experimental Setup

Hardware/OS: AMD Ryzen 5 7520U, 4 ядра, 16 GB RAM, Windows 10 x64.

Toolchain:
- CMake 3.28.3;
- компилятор g++ (Ubuntu 13.3.0-6ubuntu2~24.04) 13.3.0;
- использовался Docker-контейнер;
- режим сборки Release.

Data: для замера производительности использовался массив размером 10 000 000 элементов, заполняющийся по следующему правилу:

`
a_i = (i * 8 - 518390) mod 126659
`

## 6. Results and Discussion

### 6.1 Correctness

Корректность реализации последовательной и параллельной версий алгоритма была проверена с использованием модульных тестов Google Test.

Тестирование проводилось на массивах различного размера (1-10 элементов, 100 элементов, 1000 элементов), заполненных детерминированными значениями, включая чередование положительных и отрицательных чисел.

Результаты работы алгоритмов сравнивались с эталонной сортировкой, выполненной с помощью `std::ranges::sort`. Для MPI-версии проверка корректности выполнялась на корневом процессе.

### 6.2 Performance
| Mode | Count | Time, s | Speedup | Efficiency |
|------|-------|---------|---------|------------|
| seq  | 1     | 1.055   | 1.00    | N/A        |
| mpi  | 2     | 0.729   | 1.45    | 72.50%     |
| mpi  | 4     | 0.546   | 1.93    | 48.25%     |


## 7. Conclusions

В рамках данной работы были реализованы последовательная и параллельная версии алгоритма быстрой сортировки с простым слиянием.

Параллельная реализация использует распределение данных между процессами, локальную сортировку и последующее слияние отсортированных блоков на корневом процессе. Такой подход обеспечивает ускорение по сравнению с последовательной версией.

Однако эффективность параллельной версии ограничивается накладными расходами на передачу данных и этапом слияния, который выполняется последовательно, что заметно при увеличении числа процессов.

Полученные результаты согласуются с теоретическими ожиданиями и демонстрируют практические особенности параллельной реализации алгоритмов сортировки.

## 8. References

1. Курс лекций ННГУ «Параллельное программирование для кластерных систем»
