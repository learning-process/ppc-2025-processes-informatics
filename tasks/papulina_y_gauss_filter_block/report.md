# Линейная фильтрация изображений (блочное разбиение). Ядро Гаусса 3x3.
- Student: Папулина Юлия Андреевна, group 3823Б1ФИ3
- Technology: SEQ | MPI 
- Variant: 28

## 1. Введение
Гауссова фильтрация — операция сглаживания изображений для подавления шума. Реализованы последовательная (SEQ) и параллельная (MPI) версии с блочным разбиением данных.
## 2. Постановка задачи
**Формальная постановка:** применение Гауссова фильтра 3×3 к изображению произвольного размера с использованием метода клонирования граничных значений.

**Входные данные:**
- Изображение в формате структуры `Picture`:
  - `width` — ширина изображения в пикселях
  - `height` — высота изображения в пикселях
  - `channels` — количество каналов (1 для черно-белого, 3 для RGB)
  - `pixels` — вектор значений пикселей размером `width × height × channels`

**Выходные данные:**
- отфильтрованное изображение тех же размеров, где каждый пиксель представляет собой взвешенную сумму значений окрестности 3×3 с применением ядра Гаусса.

**Ограничения:**
- обработка граничных пикселей через клонирование граничных значений
- использование фиксированного ядра Гаусса 3×3: {[1, 2, 1], [2, 4, 2], [1, 2, 1]}
## 3. Последовательная версия (Baseline)
### Алгоритм:
1. Для каждого пикселя изображения:
2. Вычислить взвешенную сумму окрестности 3×3
3. Нормализовать результат (делить на сумму весов)
4. Ограничить значение в диапазоне [0, 255]
5. Округлить до целого числа

### Особенности:
- Использует `ClampCoordinates()` для обработки граничных пикселей
- Предварительно нормализованное ядро для оптимизации
## 4. Параллельная версия (MPI)

### 4.1. Разделение данных

Изображение разбивается на прямоугольные блоки с перекрытием (overlap = 1 пиксель) для корректной обработки границ блоков. Алгоритм определения сетки процессов находит оптимальную прямоугольную конфигурацию, максимально приближенную к квадрату. Если не удается найти подходящий делитель, используется одномерное разбиение (1×N).

Ключевые параметры разбиения:
- **Базовый размер блока:** высота и ширина блока вычисляются делением размеров изображения на размеры сетки
- **Распределение остатков:** оставшиеся строки и столбцы равномерно распределяются между первыми процессами в соответствующих размерностях
- **Фактические размеры блоков:** каждый процесс получает базовый размер плюс возможный дополнительный элемент в зависимости от его позиции в сетке
- **Расширение блоков:** каждый блок дополняется на 1 пиксель с каждой стороны для обеспечения корректной свертки на границах

### 4.2. Взаимодействие процессов
Схема работы включает пять основных этапов:
1. **Инициализация:** рассылка метаданных изображения всем процессам
2. **Распределение данных:** отправка блоков изображения рабочим процессам
3. **Параллельная обработка:** применение фильтра Гаусса к каждому блоку
4. **Сбор результатов:** возврат обработанных блоков координатору
5. **Формирование результата:** сборка полного изображения из блоков

**Особенности реализации:**
- **Клонирование границ:** для заполнения перекрытий блоков используется метод клонирования значений с границ изображения
- **Адаптивное разбиение:** автоматический подбор оптимальной сетки процессов в зависимости от количества доступных вычислителей
- **Минимальные накладные расходы:** передаются только расширенные блоки, необходимые для корректной обработки
- **Балансировка нагрузки:** равномерное распределение остатков при делении для минимизации дисбаланса
- **Корректность обработки границ:** использование перекрытий гарантирует идентичность результатов с последовательной версией на стыках блоков
- **Эффективное использование памяти:** каждый процесс хранит только свою часть данных с минимальным дублированием
## 5. Детали реализации

### 5.1. Файловая структура проекта
papulina_y_gauss_filter_block/  
├── common/include/common.hpp  
├── seq/include/ops_seq.hpp  
├── seq/src/ops_seq.cpp  
├── mpi/include/ops_mpi.hpp  
├── mpi/src/ops_mpi.cpp  
├── tests/functional/main.cpp  
├── tests/performance/main.cpp  
└── data/

### 5.2. Ключевые классы и функции

**Основные классы:**
- `PapulinaYGaussFilterSEQ` — последовательная версия
- `PapulinaYGaussFilterMPI` — параллельная MPI версия

**Ключевые методы SEQ:**
- `NewPixel()` — фильтрация одного пикселя
- `ClampCoordinates()` — обработка границ

**Ключевые методы MPI:**
- `CalculateBlock()` — подготовка блока с перекрытием
- `NewBlock()` — фильтрация блока
- `dataDistribution()` — распределение данных
- `getResult()` — сбор результатов

**Структуры данных:**
- `Picture` — хранит изображение (ширина, высота, каналы, пиксели)
- `Block` — описывает блок в MPI версии (размеры, положение)

## 6. Экспериментальное окружение

**Hardware/OS:**
- **CPU:** Intel Core i5-11400H (6 cores, 12 threads, 2.70 GHz base frequency)
- **RAM:** 16.0 GB DDR4
- **Storage:** SSD 512 GB
- **OS:** Windows 10 

**Toolchain:**
- **Compiler:** Microsoft Visual C++ 2019 (MSVC 19.29.30153)
- **MPI Implementation:** Microsoft MPI Version10.1.12498.52
- **Build System:** CMake 3.30.3
- **Build Type:** Release

**Environment:**
- **PPC_NUM_PROC:** 1, 2, 3, 4, 6 

**Data:**  матрица 1200 на 1200, использующая трех канальное представление(RGB);

## 7. Результаты

### 7.1 Корректность
Функциональное тестирование подтвердило корректность работы обеих версий алгоритма. MPI версия демонстрирует бинарную идентичность результатов с последовательной реализацией для всех тестовых случаев, включая:
- изображения различных размеров (от минимальных до крупных)
- черно-белые и цветные форматы
- граничные случаи (обработка краев изображения)
- разные соотношения сторон изображений

### 7.2 Производительность

| Режим | Процессов | Время, с | Ускорение | Эффективность |
|-------|-----------|----------|-----------|---------------|
| seq   | 1         | 1.888    | 1.00      | N/A           |
| mpi   | 2         | 0.839    | 2.25      | 112.5%        |
| mpi   | 3         | 0.691    | 2.73      | 91.0%         |
| mpi   | 4         | 0.654    | 2.89      | 72.3%         |
| mpi   | 6         | 0.759    | 2.49      | 41.5%         |

**Выводы по производительности:**
- Лучшее ускорение: 2.89× на 4 процессах
- Эффективность падает при более чем 4 процессах
- 6 процессов работают медленнее, чем 4
## 8. Заключение
1. **Алгоритм работает правильно:** MPI и SEQ дают одинаковые результаты
2. **Ускорение хорошее до 4 процессов:** до 2.89×
3. **Масштабируемость ограничена:** больше 4 процессов неэффективно
4. **Оптимально:** 3-4 процесса для этого размера данных

## 9. Источники
1. Microsoft MPI : документация [Электронный ресурс] // Microsoft Learn. – URL: https://learn.microsoft.com/ru-ru/message-passing-interface/microsoft-mpi (дата обращения: 03.11.2025).
2. Сысоев А. В. Курс лекций по параллельному программированию