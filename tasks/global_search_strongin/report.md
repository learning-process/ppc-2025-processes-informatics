# Отчет по лабораторной работе №3
## "Алгоритм глобального поиска (Стронгин)"

**Студент:** Шеленкова Мария Сергеевна  
**Группа:** 3823Б1ФИ1
**Вариант:** 11

### 1. Введение
**Мотивация.** Задачи глобальной оптимизации встречаются в инженерных расчётах и моделировании. Анализ алгоритма Стронгина с параллельной поддержкой позволяет оценить возможности масштабирования.  
**Проблематика.** Большая доля коммуникаций может нивелировать преимущества распараллеливания, особенно при дешёвой функции отклика.  
**Ожидаемый результат.** При лёгких функциях значимого ускорения не планировалось; цель эксперимента — подтвердить корректность параллельной схемы и оценить характер накладных расходов.

### 2. Постановка задачи
**Задано:** отрезок `[left, right]`, параметр точности `epsilon`, ограничение `max_iterations` и однопараметрическая функция.  
**Требуется:** найти значение глобального минимума функции на заданном отрезке.  
**Входные данные:** `InType = tuple<left, right, epsilon, max_iterations, objective>`.  
**Выходные данные:** `OutType = double` — минимальное найденное значение функции.

### 3. Последовательный алгоритм
1. Инициализация: берутся две точки на концах отрезка `left` и `right`, вычисляются значения функции, список точек сортируется по `x`.
2. На каждой итерации оценивается «крутизна» на текущем наборе точек:
	* вычисляется максимальный локальный наклон
	  \( M = \max_i \frac{|f(x_i)-f(x_{i-1})|}{x_i-x_{i-1}} \);
	* вводится параметр \( m = r\cdot M \) (здесь `r = 2.0`), а если \(M = 0\), то берётся \(m = 1\).
3. Для каждого интервала \([x_{i-1}, x_i]\) считается характеристика Стронгина:

	$$R_i = m\Delta_i + \frac{(f_i - f_{i-1})^2}{m\Delta_i} - 2(f_i + f_{i-1}),\quad \Delta_i = x_i - x_{i-1}$$

	Выбирается интервал с максимальным \(R_i\).
4. В выбранный интервал вставляется новая точка

	$$x_{new} = \frac{x_{i-1}+x_i}{2} - \frac{f_i - f_{i-1}}{2m}$$

	с защитами от выхода за границы и от попадания слишком близко к концам интервала.
5. Остановка: если длина выбранного интервала меньше `epsilon`, либо новую точку нельзя корректно вставить (дубликат/вне интервала), либо достигнут `max_iterations`.
6. Минимум (`best_point`, `best_value`) обновляется по мере добавления точек.

### 4. Схема распараллеливания
**Декомпозиция данных.** Интервалы между соседними точками распределяются между процессами (каждый процесс рассматривает свой диапазон индексов интервалов). На каждом процессе вычисляются характеристики Стронгина для локальных интервалов.

**Коммуникация.** Лучший интервал выбирается глобально через коллективную операцию (редукция по максимуму с «привязкой» к индексу/владельцу). После этого вычисляется одна новая точка для выбранного интервала и рассылается всем процессам (параметры вставки и/или обновлённый минимум).

В реализации выбор лучшего интервала выполнен канонично через `MPI_Allreduce` с типом `MPI_DOUBLE_INT` и оператором `MPI_MAXLOC` (сравнение по характеристике с переносом индекса).

**Синхронизация.** На каждой итерации выполняются глобальная редукция для выбора интервала и широковещательная рассылка данных о вставке, после чего все процессы синхронно добавляют одинаковую новую точку в свой локальный список.

### 5. Экспериментальная установка
* Процессор: 13th Gen Intel(R) Core(TM) i9-13980HX (24 физических ядра, 32 логических потока).
* Оперативная память: 32 GB.
* Операционная система: Microsoft Windows 11 Pro.
* Компилятор: MSVC 19.40, конфигурация Release x64.
* MPI-библиотека: Microsoft MPI 10.1.12498.52.

Для воспроизводимости параметры тестов и результаты замеров приведены в этом отчёте.

### 6. Результаты и обсуждение
#### 6.1. Корректность
Функциональные тесты запускались командой `ppc_func_tests.exe --gtest_filter=*global_search_strongin*`. Проверка включала несколько функций с известными минимумами; последовательная и MPI-реализации дают совпадающие результаты в пределах допуска.

#### 6.2. Производительность
Замеры выполнялись утилитой `ppc_perf_tests.exe` в конфигурации Release.

Команды запуска:
* SEQ: `ppc_perf_tests.exe --gtest_filter=*global_search_strongin_seq_enabled*`
* MPI (N процессов): `mpiexec -n N ppc_perf_tests.exe --gtest_filter=*global_search_strongin_mpi_enabled*` (проверено для N=1,2,4,8)

| Реализация | Процессов | Режим теста | Время, сек |
|-----------:|----------:|-------------|-----------:|
| seq        | 1         | pipeline    | 0.33886070 |
| seq        | 1         | task_run    | 0.06682144 |
| mpi        | 1         | pipeline    | 0.35951032 |
| mpi        | 1         | task_run    | 0.06921308 |
| mpi        | 2         | pipeline    | 0.35693232 |
| mpi        | 2         | task_run    | 0.07633388 |
| mpi        | 4         | pipeline    | 0.39469252 |
| mpi        | 4         | task_run    | 0.08500110 |
| mpi        | 8         | pipeline    | 0.65025518 |
| mpi        | 8         | task_run    | 0.12715020 |

Выполненные измерения показывают, что даже при умеренно утяжелённой функции накладные расходы MPI могут доминировать и не давать ускорения на малом числе итераций.

### 7. Выводы
Алгоритм обеспечивает корректный поиск глобального минимума и демонстрирует ожидаемое поведение производительности. Параллельная схема пригодна для задач с высокой стоимостью вычисления функции, тогда как на лёгких функциях рациональнее использовать последовательную реализацию.
