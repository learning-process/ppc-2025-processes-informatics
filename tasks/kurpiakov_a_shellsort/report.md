# Сортрировки Шелла с простым слиянием 

- Студент: Курпяков Алексей Георгиевич, 3823Б1ФИ3   
- Технологии: SEQ | MPI 
- Вариант: 16

## 1. Введение
- Проблема: cортировка массивов является одной из фундаментальных операций в информатике, широко применяемой в базах данных, поисковых системах, анализе данных и других областях

В рамках данной работы был реализована последовательная версия сортрировки Шелла и сортрировки Шелла с простым слиянием для параллельная реализация. 

Сортировка Шелла — это обобщение сортировки вставками, которая сравнивает элементы, отстоящие друг от друга на определённом расстоянии. Начиная с большого шага, алгоритм постепенно уменьшает его до 1, что эквивалентно обычной сортировке вставками.

- Ожидаемый результат: ожидается, что MPI версия будет работать быстрее последовательной за счёт распределения вычислительной нагрузки между несколькими процессами.

## 2. Постановка задачи
На вход программе подаются 2 параметра:
1. Размер входного массива(*N*).
2. Массив чисел размера N. Тип элементов - int64.

На выходе обжидается отмортированный в порядке неубывания массив чисел типа int64.

## 3. Описание линейного алгоритма

Последовательная версия:
1. Выбирается начальный шаг. [в моей реализации был выбран самый простой метод выбора шага (gap_1) = n/2, (gap_2) = n/4, ..., (gap_k-1) = 2, (gap_k) = 1]
2. Элементы, отстоящие на этом позиций, сравниваются и при необходимости меняются местами
3. Gap уменьшается в 2 раза: gap = gap/2

Асимптотическая сложность алгоритма: O(n^2), где n - размер массива


*так же шаг можно выбрать следующими методами: Хиббарда: 1, 3, 7, 15, ... (2^k - 1); Седжвика: 1, 5, 19, 41, 109, ...; Кнута: 1, 4, 13, 40, ... ((3^k - 1) / 2)*


## 4. Описание схемы параллельного алгоритма
Пусть у нас K процессов, массив A размера N, тогда алгоритм такой:
- Процессы делят матрицу и вектор на K частей.
- Части выделяются следующим образом:
- Сначала считаем минимум, который будет каждый процесс обрабатывать:
batch = N/K
- Затем вычисляем остаток от деления:
remainder = M % N
- Первые remainder процессов заберут по 1-ой колонке патрицы и по 1-му элементу вектора, остальные отработают только свой пакет.
- Затем 0-ой процесс рассылает каждому потоку свой участок памяти и его размер остальным процессам.
- После того как каждый процесс отсортровал свой подмассив, 0-ой процесс собрает результаты и при помощи простого слияния собирает результирущий вектор.

## 5. Окружение
- Hardware/OS: CPU - AMD Rizen 7 7840HS, cores - 8, RAM - 16GB, Ubuntu 24 on WSL
- Toolchain: GCC 13, Release
- Environment: PPC_NUM_PROC = 8

## 6. Результаты экспериментов и выводы

Функциональные тесты содержат 10 тестов:
 - Тест1:  пустой массив
 - Тест2:  1 элемент
 - Тест3:  отсортированный массив от 1 да 10
 - Тест4:  развернутый массив от 1 да 10
 - Тест5:  массив с повторяющимися числами
 - Тест6:  массив случайных чисел с N = 10
 - Тест7:  массив случайных чисел с N = 1000

Тест на производительность - N = 100000
исходный массив заполнен числами от 0 до N-1 в порядке невозрастания


Ниже таблица с результатами Perf тестов.

В таблице представлено: Mode - запускаемая версрия, Count - количество процессов, Time - время выполнения в секундах, Speedup - полученное ускорение, Efficiency - 

| Mode        | Count | Time, s | Speedup | Efficiency |
|-------------|-------|---------|---------|------------|
| seq         | 1     | 0.164   | 1.00    | N/A        |
| mpi         | 2     | 0.090   | 1,82    | 91%        |
| mpi         | 4     | 0.048   | 3,41    | 85%        |

*результат был получен при запуске build/bin/ppc_perf_tests*

При замерах была получена данная таблица.

Мною было получено ускорение приближенное к идеальному, но недостающего до ускорения в counts раз для каждого эксперимента. 

Это нормально, потому что операция сравнения и логические ветвления выполняются с простоем процессора, поэтому работа сразу нескольких потоков ускоряет сортровку. Однако, слияние массивов и рассылка данных не дает этому алгоритму работать с идеальным ускорением.

## 7. Заключение
В результате работы в учебных целях разработаны последовательная (SEQ) и параллельная (MPI) версии программы, реализующей сортировку Шелла массива в порядке неубывания. Полученные результаты демонстрируют работоспособность реализации и позволяют проанализировать особенности масштабирования и распараллеливания данного алгоритма.


## Источники
1. Лекции А. В. Сысоева по курсу "Параллельное программирование для кластерных систем"
2. [Документация OpenMPI](https://www.open-mpi.org/doc/)
3. [cppreference.com](https://en.cppreference.com/)
4. [Стандарт C++](https://www.open-std.org)