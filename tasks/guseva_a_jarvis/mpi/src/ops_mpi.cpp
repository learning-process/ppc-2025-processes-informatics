#include "guseva_a_jarvis/mpi/include/ops_mpi.hpp"

#include <cmath>
#include <cstddef>
#include <cstdint>
#include <vector>

#include "guseva_a_jarvis/common/include/common.hpp"

namespace guseva_a_jarvis {

GusevaAJarvisMPI::GusevaAJarvisMPI(const InType &in) {
  SetTypeOfTask(GetStaticTypeOfTask());
  GetInput() = in;
  GetOutput() = std::vector<int>();

  MPI_Comm_rank(MPI_COMM_WORLD, &rank_);
  MPI_Comm_size(MPI_COMM_WORLD, &size_);
}

bool GusevaAJarvisMPI::ValidationImpl() {
  const auto &input_tuple = GetInput();
  const int width = std::get<0>(input_tuple);
  const int height = std::get<1>(input_tuple);
  const std::vector<int> &image = std::get<2>(input_tuple);

  int validation_result = 0;

  if (rank_ == 0) {
    const bool is_size_match = static_cast<int>(image.size()) == width * height;

    bool is_image_binary = true;
    for (const int pixel_value : image) {
      if (pixel_value != 0 && pixel_value != 1) {
        is_image_binary = false;
        break;
      }
    }

    const bool is_size_possible = width > 0 && height > 0;
    validation_result = (is_image_binary && is_size_possible && is_size_match) ? 1 : 0;
  }

  MPI_Bcast(&validation_result, 1, MPI_INT, 0, MPI_COMM_WORLD);

  return validation_result == 1;
}

bool GusevaAJarvisMPI::PreProcessingImpl() {
  const auto &input_tuple = GetInput();
  const int width = std::get<0>(input_tuple);
  const int height = std::get<1>(input_tuple);
  const std::vector<int> &image = std::get<2>(input_tuple);

  points_.clear();

  for (int yy = 0; yy < height; ++yy) {
    for (int xx = 0; xx < width; ++xx) {
      if (image[(yy * width) + xx] == 1) {
        points_.emplace_back(xx, yy);
      }
    }
  }

  return true;
}

namespace {

int CrossProduct(const std::pair<int, int> &a, const std::pair<int, int> &b, const std::pair<int, int> &c) {
  return ((b.first - a.first) * (c.second - a.second)) - ((b.second - a.second) * (c.first - a.first));
}

int DistanceSquared(const std::pair<int, int> &a, const std::pair<int, int> &b) {
  int dx = b.first - a.first;
  int dy = b.second - a.second;
  return (dx * dx) + (dy * dy);
}

// NOLINTNEXTLINE
std::vector<std::pair<int, int>> BuildConvexHull(const std::vector<std::pair<int, int>> &points) {
  if (points.size() <= 3) {
    return points;
  }

  std::vector<std::pair<int, int>> hull;

  size_t start_idx = 0;
  for (size_t i = 1; i < points.size(); ++i) {
    if (points[i].first < points[start_idx].first ||
        (points[i].first == points[start_idx].first && points[i].second < points[start_idx].second)) {
      start_idx = i;
    }
  }

  size_t current = start_idx;

  // NOLINTNEXTLINE
  do {
    hull.push_back(points[current]);
    size_t next = (current + 1) % points.size();

    for (size_t i = 0; i < points.size(); ++i) {
      if (i == current) {
        continue;
      }

      int cross = CrossProduct(points[current], points[next], points[i]);

      if (cross < 0) {
        next = i;
      } else if (cross == 0) {
        int dist1 = DistanceSquared(points[current], points[next]);
        int dist2 = DistanceSquared(points[current], points[i]);
        if (dist2 > dist1) {
          next = i;
        }
      }
    }

    current = next;

  } while (current != start_idx);

  return hull;
}
}  // namespace

bool GusevaAJarvisMPI::RunImpl() {
  std::vector<std::pair<int, int>> local_hull = BuildConvexHull(points_);

  int64_t local_hull_size = static_cast<int>(local_hull.size());
  std::vector<int> all_hull_sizes(size_, 0);

  MPI_Gather(&local_hull_size, 1, MPI_INT, all_hull_sizes.data(), 1, MPI_INT, 0, MPI_COMM_WORLD);

  std::vector<int> displacements(size_, 0);
  std::vector<int> recv_counts(size_, 0);
  int64_t total_points = 0;

  if (rank_ == 0) {
    for (int i = 0; i < size_; ++i) {
      recv_counts[i] = all_hull_sizes[i] * 2;
      displacements[i] = static_cast<int>(total_points) * 2;
      total_points += all_hull_sizes[i];
    }
  }

  std::vector<int> local_data(local_hull_size * 2);
  for (int64_t i = 0; i < local_hull_size; ++i) {
    local_data[i * 2] = local_hull[i].first;
    local_data[(i * 2) + 1] = local_hull[i].second;
  }

  std::vector<int> all_data;
  if (rank_ == 0) {
    all_data.resize(total_points * 2, 0);
  }

  MPI_Gatherv(local_data.data(), static_cast<int>(local_hull_size * 2), MPI_INT, all_data.data(), recv_counts.data(),
              displacements.data(), MPI_INT, 0, MPI_COMM_WORLD);

  if (rank_ == 0) {
    std::vector<std::pair<int, int>> all_points;
    all_points.reserve(total_points);
    for (int64_t i = 0; i < total_points; ++i) {
      all_points.emplace_back(all_data[i * 2], all_data[(i * 2) + 1]);
    }

    hull_ = BuildConvexHull(all_points);
  }

  return true;
}

bool GusevaAJarvisMPI::PostProcessingImpl() {
  const auto &input_tuple = GetInput();
  const int width = std::get<0>(input_tuple);
  const int height = std::get<1>(input_tuple);

  int64_t hull_size = 0;
  if (rank_ == 0) {
    hull_size = static_cast<int>(hull_.size());
  }

  MPI_Bcast(&hull_size, 1, MPI_INT, 0, MPI_COMM_WORLD);

  std::vector<int> hull_data;
  if (rank_ == 0) {
    hull_data.resize(hull_size * 2, 0);
    for (int64_t i = 0; i < hull_size; ++i) {
      hull_data[i * 2] = hull_[i].first;
      hull_data[(i * 2) + 1] = hull_[i].second;
    }
  } else {
    hull_data.resize(hull_size * 2, 0);
  }

  MPI_Bcast(hull_data.data(), static_cast<int>(hull_size) * 2, MPI_INT, 0, MPI_COMM_WORLD);

  if (rank_ != 0) {
    hull_.clear();
    hull_.reserve(hull_size);
    for (int64_t i = 0; i < hull_size; ++i) {
      hull_.emplace_back(hull_data[i * 2], hull_data[(i * 2) + 1]);
    }
  }

  std::vector<int> output_vector(static_cast<int64_t>(width) * height, 0);

  for (const auto &point : hull_) {
    const int x = point.first;
    const int y = point.second;
    if (x >= 0 && x < width && y >= 0 && y < height) {
      output_vector[(y * width) + x] = 1;
    }
  }

  GetOutput() = output_vector;

  return true;
}

}  // namespace guseva_a_jarvis
