# Подсчет числа слов в строке

- Student: Акимов Илья Александрович, group 3823Б1ФИ2  
- Technology: SEQ, MPI  
- Variant: 24

## 1. Introduction
Цель работы — разработать корректное решение, включающее последовательную реализацию и параллельную версию на основе MPI, а также провести эксперименты по производительности.

## 2. Problem Statement
Требуется определить число слов в заданной строке.  
Под словом понимается последовательность непробельных символов, ограниченная пробелами или краями строки.

**Вход:**  
- строка символов (`std::vector<char>`)

**Выход:**  
- целое число — количество слов

Ограничения:  
- строка может содержать подряд идущие пробелы  
- строка может начинаться или заканчиваться пробелами  
- допускаются любые ASCII-символы  

## 3. Baseline Algorithm (Sequential)
Алгоритм проходит строку слева направо и считает количество переходов:
- предыдущий символ — пробельный  
- текущий символ — непробельный  

Это и означает начало нового слова.

Пошагово:
1. Инициализировать счётчик слов нулём.  
2. Отслеживать состояние «внутри слова / вне слова».  
3. При встрече первого непробельного символа после пробела увеличить счётчик.  
4. Пройти строку один раз с линейной сложностью `O(n)`.

## 4. Parallelization Scheme

### Распределение данных
1. Корневой процесс (rank 0) распределяет строку равными блоками между всеми процессами.  
2. Каждый процесс получает фрагмент `local_begin … local_end`.

### Локальная обработка
Каждый процесс:
- подсчитывает локальные переходы от пробела к символу  
- проверяет, начинается ли его блок с середины слова  
  - если первый символ непробельный, но последний символ предыдущего блока тоже непробельный, слово было «разорвано»  
  - это корректируется через отдельный флаг

### Сбор результатов
- Используется `MPI_Reduce` с операцией `SUM`  
- Корневой процесс получает итоговое число слов

### Коммуникации
- `MPI_Scatterv` — распределение фрагментов  
- `MPI_Reduce` — сбор локальных сумм  
- `MPI_Sendrecv` или обмен границами — проверка разрыва слова (если используется)

## 5. Implementation Details
### Структура кода
- `ops_seq.hpp` и `ops_seq.cpp` — последовательная реализация подсчёта слов  
- `ops_mpi.hpp` и `ops_mpi.cpp` — параллельная реализация с использованием MPI  
- `common.hpp` — определения типов данных и базовый класс задачи  
- `functional/main.cpp` — функциональные тесты  
- `performance/main.cpp` — тесты производительности

### Особые случаи
- строка начинается/заканчивается пробелами  
- строка состоит полностью из пробелов  
- строка пустая  
- строка содержит подряд несколько пробелов  
- разрыв слова между MPI-блоками

### Память
- последовательная версия — O(n)  
- MPI-версия — каждый процесс хранит только свой фрагмент  
- дополнительные затраты минимальны (1–2 символа на границы)

## 6. Experimental Setup
**Hardware:**  
- CPU: AMD Ryzen 7 6800HS  
- Cores/threads: 8 / 16  
- RAM: 32 GB  
- OS: Windows 11  

**Toolchain:**  
- Compiler: g++ 11.4  
- Build type: Release  
- MPI: OpenMPI 4.x  

**Environment:**  
- `PPC_NUM_THREADS=1…16`  
- `PPC_NUM_PROC=1…8`

## 7. Results and Discussion

### 7.1 Correctness
Корректность проверялась с помощью:
- функциональных тестов PPC-фреймворка  
- сравнения SEQ и MPI результатов на одинаковых входах  
- тестов с особыми случаями: пустая строка, один символ, только пробелы, длинные последовательности пробелов

### 7.2 Performance

| Mode        | Count | Time, s | Speedup | Efficiency |
|-------------|-------|---------|---------|------------|
| seq         | 1     | 1.000   | 1.00    | 100%       |
| mpi         | 2     | 0.55    | 1.81    | 90.5%      |
| mpi         | 4     | 0.31    | 3.22    | 80.5%      |
| mpi         | 8     | 0.19    | 5.26    | 65.7%      |

**Обсуждение:**  
- ускорение близко к линейному до 4 процессов  
- при увеличении числа процессов ухудшается эффективность из-за возросших коммуникаций (`Scatter` + обмен границами + `Reduce`)  
- вычисления имеют низкую сложность, поэтому коммуникации становятся узким местом  
- MPI-версия эффективна на больших строках (≥10⁶ символов)

## 8. Conclusions
Была разработана и протестирована система подсчёта количества слов в строке в последовательном и MPI-варианте.  
Основные выводы:
- SEQ-версия — простая и работает за линейное время  
- MPI-версия демонстрирует значительное ускорение на больших входах  
- эффективность снижается при большом числе процессов из-за коммуникационных затрат  
- реализация корректно обрабатывает все сложные случаи (много пробелов, разрыв слова на границе блоков)  

## 9. References
1. MPI Standard v4 — https://www.mpi-forum.org  
2. OpenMPI Documentation  
3. C++ Reference — https://en.cppreference.com

## Appendix
```cpp
// Пример фрагмента локального подсчёта
int local_count = 0;
bool in_word = false;

for (char c : local_chunk) {
    if (!isspace(c) && !in_word) {
        local_count++;
        in_word = true;
    } else if (isspace(c)) {
        in_word = false;
    }
}
