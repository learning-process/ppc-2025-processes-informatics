# Ленточная вертикальная схема - умножение матрицы на вектор

- Студент: Курпяков Алексей Георгиевич, 3823Б1ФИ3   
- Технологии: SEQ | MPI 
- Вариант: 12

## 1. Введение
В рамках данной работы был реализована ленточная вертикальная схема умножения матрицы на вектор: последовательна и параллельная реализация. 
- Проблема: задача умножения матрицы на вектор - распространненая задача в линейной алгебре, поэтому ее оптмизация вызывает интерес.
- Ожидаемый результат: ожидается, что MPI версия будет работать быстрее последовательной за счёт распределения вычислительной нагрузки между несколькими процессами.

## 2. Постановка задачи
На вход программе подаются 4 параметра:
1. Количество строк и столбцов(*N*).
2. Квадратная матрица A в виде одноменонго вектора чисел. Тип элементов - int64.
3. Вектор v в виде одномерного массива чисел. Тип элементов - int64.
Требуется вычислить вектор b, который является произведением матрицы A и вектора v:    $A*v = b$.

## 3. Описание линейного алгоритма

Последовательная версия:
каждый элемент матрицы домножаем в соответствующий элемент вектора и прибавляем получишееся значение к соответствующему элементу результирующего вектора. 


## 4. Описание схемы параллельного алгоритма
Пусть у нас K процессов, матрица А размера N*N, и вектор v размера N,, тогда алгоритм такой:
- Процессы делят матрицу и вектор на K частей. Матрицу по стобцам, вектор построчкам. 
- Части выделяются следующим образом:
- Сначала считаем минимум, который будет каждый процесс обрабатывать:
batch = N/K
- Затем вычисляем остаток от деления:
remainder = M % N
- Первые remainder процессов заберут по 1-ой колонке патрицы и по 1-му элементу вектора, остальные отработают только свой пакет.
- Затем 0-ой процесс рассылает каждому потоку свой участок памяти и его размер остальным процессам.
- После того как каждый процесс отработал свой участок и посчитал сумму внутри своего вектора 0-ой процесс собрает результаты, суммирует и записывает их в один результирующий вектор.

## 5. Окружение
- Hardware/OS: CPU - AMD Rizen 7 7840HS, cores - 8, RAM - 16GB, Ubuntu 24 on WSL
- Toolchain: GCC 13, Release
- Environment: PPC_NUM_PROC = 8

## 6. Результаты экспериментов и выводы

Функциональные тесты содержат 10 тестов:
 - Тест1:  пустые матрица и вектор
 - Тест2:  умножение скаляров
 - Тест3:  умножение матрицы 2х2 на вектор 1х2
 - Тест4:  умножение матрицы 3х3 на вектор 1х3
 - Тест5:  умножение нулевой матрицы на нулевой вектор
 - Тест6:  умножение ненулевой матрицы на нулевой вектор
 - Тест7:  умножение матрицы на вектор с отрицательными элементами
 - Тест8:  умножение с переполнением типа int
 - Тест9:  умножение симметричной матрицы на вектор
 - Тест10: умножение матрицы на вектор

Тест на производительность - N = 8500
=> размер матрицы = 72250000
=> размер вектора = 8500
Матрица заполняется так, что:

$i == j => A[i][j] = i$

$i != j => A[i][j] = 0$

Вектор заполняется единицами

Ниже таблица с результатами Perf тестов.

В таблице представлено: Mode - запускаемая версрия, Count - количество процессов, Time - время выполнения в секундах, Speedup - полученное ускорение, Efficiency - 

| Mode        | Count | Time, s | Speedup | Efficiency |
|-------------|-------|---------|---------|------------|
| seq         | 1     | 6.164   | 1.00    | N/A        |
| mpi         | 2     | 3.811   | 1.62    | 81%        |
| mpi         | 4     | 3.345   | 1.84    | 46%        |

*результат был получен при запуске build/bin/ppc_perf_tests*

*к сожалению, запустить программу на 8 процессах не удалось из-за слабого железа*

При замерах была получена данная таблица.

Мною не было получено идеальное ускорение в count раз для каждого эксперимента. 

Это нормально, потому что операция умножения и сложения отлично векторизуется и выполняется за 1-4 тика процессора на современных процессорах с архитектурой x86.Так же много времени забирает операция раздачи элементов вектора каждому процессу и рассчет смещений и размеров пераедаваемых пакетов.

Так же можно отметить неидеальность данного алгоритма в плане кэш-промахов. Так как матрица храниться последоватеьлно в памяти одномерным массиво => в кэш подгружается матрица строками, а так как алгоритм заточен на работу со столбцами, обязательно будет появляться большое количество промахов в быстродоступную память, что на больших объемах данных будет формировать большое количество простоев у процессов из-за накладных расходов работы с памятью.

## 7. Заключение
В результате работы в учебных целях разработаны последовательная (SEQ) и параллельная (MPI) версии программы, реализующей ленточную вертикальную схему умножения матрицы на вектор. Полученные результаты демонстрируют работоспособность реализации и позволяют проанализировать особенности масштабирования данного алгоритма.


## Источники
1. Лекции А. В. Сысоева по курсу "Параллельное программирование для кластерных систем"
2. [Документация OpenMPI](https://www.open-mpi.org/doc/)
3. [cppreference.com](https://en.cppreference.com/)
4. [Стандарт с++](https://www.open-std.org)