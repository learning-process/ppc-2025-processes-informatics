# <Проверка лексикографической упорядоченности двух строк>

* **Студент:** Егашин Кирилл Олегович, группа 3823Б1ФИ2
* **Технологии:** SEQ | MPI
* **Вариант:** 26

## 1. Введение

**Цель:** Сравнить две строки (определить, какая из них идет раньше по алфавиту) и проверить, ускорит ли эту задачу использование нескольких процессов.

**Проблема:** Сравнение символов - это очень быстрая операция. Основное время уходит на чтение данных из памяти. Когда мы используем MPI, добавляется время на пересылку данных между процессами. Есть риск, что пересылка займет больше времени, чем само сравнение.

**Ожидание:** На одном компьютере последовательная версия будет быстрее. Параллельная версия, вероятно, имеет смысл только для огромных данных, которые не влезают в память одного компьютера.

## 2. Постановка задачи

**Дано:** Две строки `S1` и `S2`.
**Надо узнать:** Верно ли, что `S1` меньше `S2` (идет раньше в словаре).

**Правила сравнения:**
Строка `S1` меньше `S2`, если:

1. В первой позиции, где символы не совпадают, у `S1` символ меньше.
2. Если строки совпадают, но `S1` короче.

**Вход:** Две строки.
**Выход:** `true` или `false`.

## 3. Описание алгоритма (SEQ)

1. Находим длину самой короткой строки.
2. Идем по символам от начала:
   * Если нашли символ в `S1`, который меньше чем в `S2` -> возвращаем `true`.
   * Если нашли символ в `S1`, который больше -> возвращаем `false`.
3. Если дошли до конца короткой строки и различий нет, сравниваем их длины.

Сложность: Линейная `O(N)`.

## 4. Схема распараллеливания (MPI)

Мы делим строки на части, и каждый процесс проверяет свой кусок.

1. **Главный процесс (Rank 0)** считает общую длину для сравнения и сообщает её всем остальным (`MPI_Bcast`).
2. **Разбиение:** Длина делится на количество процессов. Например, если длина 100 и процессов 4, каждому достанется по 25 символов.
3. **Рассылка (`MPI_Scatterv`):** Главный процесс раздает куски строк `S1` и `S2` всем рабочим процессам.
4. **Проверка на местах:** Каждый процесс сравнивает свои куски и возвращает локальный результат.
5. **Сбор ответов (`MPI_Gather`):** Все ответы собираются у главного процесса в массив.
6. **Итог:** Главный процесс смотрит на ответы слева направо. Первый же ответ, который не `0` - решение. Если все `0`, сравниваем длины строк.

## 5. Экспериментальное окружение

### Хост-система (ПК)

* **ОС:** Microsoft Windows 11 Pro, 64-разрядная
* **Процессор:** Intel Core i5-9600K @ 3.70GHz (6 ядер, 6 потоков)
* **Оперативная память:** 32 ГБ

### Docker-контейнер

* **Базовый образ:** Ubuntu 24.04
* **Компилятор:** GCC 14 (g++-14)
* **MPI:** OpenMPI + MPICH
* **Система сборки:** CMake, Ninja
* **Дополнительно:** LLVM/Clang 21, OpenMP, Valgrind, ccache

### Тестовые данные

* Строки длиной **20 000 000** символов
* Строки специально сделаны одинаковыми почти до самого конца, чтобы алгоритму пришлось проверить всё

## 6. Результаты

### 6.1 Корректность

20 тестов:

* Пустые строки.
* Одинаковые строки.
* Разные длины.
* Различия в начале, середине, конце.
Все тесты пройдены.

### 6.2 Производительность

Время работы на строках в 20 млн символов:

| Режим | Кол-во процессов | Время (сек) | Ускорение | Эффективность |
|:-----:|:----------------:|:-----------:|:---------:|:-------------:|
| **seq** | **1** | **0.03636** | **1.00** | **100%** |
| mpi | 2 | 0.04926 | 0.74 | 37% |
| mpi | 4 | 0.07510 | 0.48 | 12% |

**Вывод по таблице:**
Параллельная версия работает медленнее. Ускорение меньше 1 (то есть замедление).
Время на упаковку и пересылку данных через MPI тратится больше, чем на мгновенное сравнение символов процессором.

## 7. Заключение

В этой работе реализовано параллельное сравнение строк через MPI.

Эксперименты показали, что для задачи сравнения символов на одном компьютере MPI использовать невыгодно - накладные расходы съедают всё ускорение. Обычный цикл работает быстрее.

Однако этот алгоритм будет полезен, если данные лежат на разных компьютерах в сети и их нельзя собрать в одном месте. Тогда делить задачу на части - единственное решение.

## 8. Источники

1. MPI Standard Documentation - https://www.mpi-forum.org/docs/
2. Лекции и практики по параллельному программированию

## Приложение

**Код принятия решения (у главного процесса):**

```cpp
if (rank == 0) {
  int final_decision = 0;
  // Идем слева направо, ищем первое различие
  for (int i = 0; i < size; ++i) {
    if (global_results[i] != 0) {
      final_decision = global_results[i];
      break;
    }
  }
  
  if (final_decision != 0) {
    GetOutput() = (final_decision == -1);
  } else {
    // Если все части равны, решает длина
    GetOutput() = (s1_len < s2_len);
  }
}
