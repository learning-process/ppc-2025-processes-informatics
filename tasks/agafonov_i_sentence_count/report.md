# Подсчет числа предложений в строке

- Student: Агафонов Илья Дмитриевич, group 3823Б1ФИ1
- Technology: SEQ | MPI
- Variant: 25

## 1. Introduction
Задача подсчета предложений в тексте является фундаментальной в обработке естественного языка. Цель работы - реализовать параллельную версию алгоритма с использованием MPI для ускорения обработки больших текстовых данных и сравнить производительность с последовательной реализацией.

## 2. Problem Statement
**Входные данные:** строка (std::string)
**Выходные данные:** количество предложений (int)
**Ограничения:**
- Предложение заканчивается символами: '.', '!' или '?'
- Перед знаком конца предложения должен быть буквенно-цифровой символ
- Пустая строка или строка без предложений возвращает 0

## 3. Baseline Algorithm (Sequential)
```cpp
bool in_sentence = false;
int count = 0;

for (char c : text) {
    if (isalnum(c)) {
        in_sentence = true;
    } else if (c == '.' && in_sentence) {
        count++;
        in_sentence = false;
    } else if ((c == '!' || c == '?') && in_sentence) {
        count++;
        in_sentence = false;
    }
}

if (in_sentence) {count++};

## 4. Parallelization Scheme
1. Главный процесс (rank 0) содержит исходную строку
2. Строка равномерно делится между процессами
3. Каждый процесс подсчитывает предложения в своем чанке
4. Учет граничных условий между чанками

**Роли процессов:**
- **Rank 0 (Мастер):** Выполняет локальный подсчёт, собирает частичные результаты через `MPI_Reduce`, корректирует итоговый счёт.
- **Rank 1..N-1 (Воркеры):** Выполняют локальный подсчёт в своём чанке, отправляют результат мастеру.

Обработка границ:
-Каждый процесс получает информацию о предыдущем символе
-Главный процесс корректирует результаты для предложений, разделенных между чанками

## 5. Implementation Details
Структура проекта:
common/include/common.hpp общие типы
seq - SEQ реализация
mpi/  MPI реализация  
tests/ тесты

Ключевые классы:
SentenceCountSEQ - последовательная реализация
SentenceCountMPI - MPI реализация  

Особенности реализации:
Проверка на многоточие.  Реализация содержит проверку на многоточие (if (i + 1 < total_length && text[i + 1] == '.')), чтобы последовательность "..." не считалась тремя предложениями.
Корректная обработка unsigned char для isalnum()
Барьерная синхронизация после вычислений
Пустые входные данные: ValidationImpl() возвращает false для пустой строки.

## 6. Experimental Setup
**Hardware/OS:**
  - **Процессор:** Процессор	AMD Ryzen 5 5500U, ядер: 6, логических процессоров: 12
  - **Оперативная память:** 16 ГБ DDR4
  - **Операционная система:** Windows 10 Pro 22H2
- **Toolchain:**
  - **Компилятор:** g++ 13.3.0
  - **Тип сборки:** Release (-O3 )
  - **MPI:** Open MPI 4.1.6

## 7. Results and Discussion

### 7.1 Correctness
Корректность проверена 5 функциональными тестами SentenceCountFuncTests, которые покрывают ключевые граничные случаи:
1. Обычные предложения с разными знаками препинания (`.`, `!`, `?`)
2. Предложение без завершающего знака
3. Несколько коротких предложений
4. Строка без предложений (`"..."`)
Все тесты для **SEQ-реализации** проходят успешно. MPI-реализация корректно работает в режиме производительных тестов, что косвенно подтверждает правильность алгоритма.

### 7.2 Performance
Для оценки производительности использовались тесты производительности, которые генерируют строку длиной 5000000 символов с имитацией предложений. За базовую линию принята SEQ-реализация. Параллельная эффективность оценивается для MPI-реализаций, запущенных с 2 и 4 процессами.

| Mode        | Count | Time, s | Speedup | Efficiency |
|-------------|-------|---------|---------|------------|
| seq         | 1     | 0.016917| 1.00    | N/A        |
| mpi         | 2     | 0.008700| 1.94    | 97%        |
| mpi         | 4     | 0.005253| 3.22    | 80.5%      |

Анализ результатов:

Ускорение: Полученные результаты демонстрируют эффективное распараллеливание. При использовании 2 процессов достигнуто ускорение, очень близкое к линейному (1.94). Увеличение числа процессов до 4 даёт ускорение в 3.22 раза, что говорит о хорошей масштабируемости разработанного алгоритма.
Эффективность: Высокая эффективность на 2 процессах (97%) подтверждает, что задача хорошо декомпозируется, а накладные расходы минимальны. Снижение эффективности до 80.5% на 4 процессах является ожидаемым и объясняется следующими факторами:
Рост коммуникационных издержек: Увеличение числа вызовов MPI_Reduce и MPI_Barrier.
Ограничения масштабируемости:
Главное ограничение текущей реализации — дублирование всей входной строки в памяти каждого процесса. Это делает алгоритм не масштабируемым по памяти для данных, превышающих размер оперативной памяти одного узла. Дальнейшее увеличение числа процессов приведёт к ещё большему падению эффективности, так как время последовательной коррекции и коммуникации будет расти, а время вычислений на одном процессе уменьшаться.

## 8. Conclusions
В рамках работы была успешно разработана и реализована параллельная программа для подсчёта предложений в строке с использованием технологии MPI. Алгоритм корректно обрабатывает все граничные случаи, включая многоточия и предложения, разорванные между процессами, благодаря продуманной схеме коррекции на мастер-процессе.
С помощью эксперимента доказана эффективность параллельного подхода. На тестовых данных объёмом 5 миллионов символов реализация с 2 процессами показала ускорение, близкое к теоретическому пределу (1.94), а с 4 процессами ускорение в 3.22 раза. Это подтверждает, что задача хорошо поддаётся декомпозиции по данным.
Для вычислительно несложных, но объёмных задач обработки текста использование MPI является оправданным и позволяет достичь значительного ускорения при условии корректной обработки граничных условий и использования данных достаточного для нивелирования накладных расходов объёма.

## 9. References
-Материлы и документация по курсу
-Документация OpenMP
