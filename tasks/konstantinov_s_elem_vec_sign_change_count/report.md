# Нахождение числа чередований знаков значений соседних элементов вектора

- Student: Константинов Семён Анатольевич, group 3823Б1ФИ3
- Technology: SEQ | MPI
- Variant: 5

## 1. Introduction
Задача подсчёта числа чередований знака элементов вектора - простая задача с немного нетривиальными способами распараллеливания. Ускорение параллельного решения должно быть близко к количеству процессов.

## 2. Problem Statement
### Входные данные:

Дан вектор длины `N`, состоящий из элементов типа `double`. Считаем что элементов-нулей во входном векторе нет.

### Выходные данные:

Значение типа `int`, равное количеству смен знака значения соседних элементов вектора.

## 3. Baseline Algorithm (Sequential)
Инициализируем ответ значением 0. Проходимся циклом по элементам вектора от 0 до `N-2`, прибавляя к ответу 1 если знак текущего элемента не соответствует знаку следующего.

## 4. Parallelization Scheme
Нулевой ранг (будем называть его корень) вычисляет и отправляет другим процессам step - число элементов вектора, выделяемых каждому процессу. 
Процессам выделяются подряд идущие подмассивы так, что последний элемент текущего массива совпадает с первым элементом следующего, это необходимо для правильного подсчёта чередований знаков на границе блоков.
Корень рассылает по step элементов на остальные процессы с помощью MPI_Scatterv, первый блок и остаток оставляет себе (остаток не больше количества процессов, не имеет смысл усложнять логику распределения пересекающихся блоков).
Каждый процесс обрабатывает свою часть данных по ранее описанному последовательному алгоритму.
Благодаря тому что блоки пересекаются не теряются смены знака на стыках, поэтому для получения итогового количества используется редукция суммой (MPI_Allreduce).

## 5. Experimental Setup
- Hardware/OS: ЦП AMD Ryzen 5 3600 6-Core Processor, 16 GB RAM, Windows 10 x64
- Toolchain: Cmake 4.2.0, Visual Studio 2022, MSVC, x64 Release
- Environment: PPC_NUM_THREADS=PPC_NUM_PROC=1/2/4/6/8/10/12/14/16/20/24/32/40/60/80, PPC_PERF_MAX_TIME=10000
- Data: стабильная генерация тестовых данных путём повторения вектора-образца, для теста производительности генерируется вектор в 150000000 элементов

## 6. Results and Discussion

### 6.1 Correctness
Вектор-образец для генерации тестов имеет известное число смен знака (образец все комбинации знаков соседних элементов) и одинаковый знак первого и последнего элемента, верное число смен знака для тестовых данных вычисляется на этапе генерации умножением этого числа из образца на количество целых образцов в итоговом массиве (остаток не содержит смен знака).
Корректность проверена на векторах разных размеров.

### 6.2 Performance

| Mode        | Count | Time, s | Speedup | Efficiency |
|-------------|-------|---------|---------|------------|
| seq         | 1     | 0.706   | 1.00    | N/A        |
| omp         | 2     | 1.080   | 0.65    | 32.5%      |
| omp         | 3     | 1.065   | 0.66    | 22%      |
| omp         | 4     | 1.011   | 0.69    | 17.25%     |

## 7. Conclusions
Данных много, операции недорогие и их мало - больше времени уходит на работу с памятью, чем на вычисления. Накладные расходы MPI на пересылку данных серьёзно уменьшают эффективность. Без пересылки данных ускорение могло бы быть близким к линейному (параллелизация вынуждает обрабатывать лишь на один элемент больше каждому процессу).

## 8. References
1. Курс лекций ННГУ "Параллельное программирование для кластерных систем"
