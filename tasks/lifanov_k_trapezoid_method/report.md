# Собственная реализация параллельного вычисления двумерного интеграла методом трапеций(SEQ + MPI)

**Студент:** Лифанов Кирилл Максимович \
**Группа:** 3823Б1ФИ2 \
**Технология:** SEQ + MPI \
**Вариант:** 8 

-- -

## 1. Введение

Цель работы: разработать последовательную и параллельную реализацию метода трапеций для вычисления двумерного интеграла от функции \f = x^2 + y^2.

Метод трапеций - численный метод, позволяющий аппроксимировать интеграл функции \(f(x, y)\)на прямоугольной области ([a, b ]\times[c, d]\) через разбиение области на сетку и суммирование значений функции с весовыми коэффициентами.

-- -

## 2. Постановка задачи

Задано: функция \(f(x, y)\)и прямоугольная область интегрирования \([ a, b ]\times[c, d]\)с числом разбиений \(n_x, n_y\).

Требуется вычислить интеграл:

\[ I = \int_a^b \int_c^d f(x, y) \, dy \, dx \]

### Ограничения

- \(n_x, n_y >= 1\) - область интегрирования не должна быть вырожденной
- функция \(f(x, y)\)конечна и непрерывна 
- результаты SEQ и MPI реализаций должны совпадать

-- -

## 3. Последовательная реализация(SEQ)

``` cpp
const double a = GetInput()[0];
const double b = GetInput()[1];
const double c = GetInput()[2];
const double d = GetInput()[3];
const int nx = static_cast<int>(GetInput()[4]);
const int ny = static_cast<int>(GetInput()[5]);

const double hx = (b - a) / nx;
const double hy = (d - c) / ny;

double sum = 0.0;
for (int i = 0; i <= nx; ++i) {
  double x = a + i * hx;
  double wx = (i == 0 || i == nx) ? 0.5 : 1.0;

  for (int j = 0; j <= ny; ++j) {
    double y = c + j * hy;
    double wy = (j == 0 || j == ny) ? 0.5 : 1.0;
    sum += wx * wy * f(x, y);
  }
}

GetOutput() = sum * hx * hy;
```

Алгоритм выполняет двойной проход по сетке и имеет сложность O(nx·ny)

## 4. Параллельная реализация(MPI)

MPI - версия распределяет разбиение области интегрирования по оси \(x\)между процессами, чтобы каждый процесс выполнял вычисления на своей полосе сетки.

## 4.1 Декомпозиция данных

При `p` процессах каждому процессу выделяется определённое количество столбцов сетки по оси \(x\):

```cpp 
base = nx / p;                                    // базовое количество столбцов на процесс
rem =nx % p;                                             // остаток для распределения
i_start(rank) = rank * base + min(rank, rem);             // начальный индекс столбца
i_end(rank) = i_start + base - 1 + (rank < rem ? 1 : 0);  // конечный индекс столбца
```

Каждый процесс вычисляет интеграл на своей полосе по оси x, суммируя значения функции с весами трапеций

После того как каждый процесс подсчитал свою локальную сумму, используется коллективная операция MPI_Reduce для суммирования локальных интегралов на корневом процессе

На корневом процессе результат умножается на шаги сетки hx *hy

Таким образом, получается полное значение интеграла на всей области.

## 5. Производительность

Фактические результаты вычисления двумерного интеграла методом трапеций были получены на крупной сетке размером 2000 × 2000.

| Режим | Процессы | Время(с) | Ускорение S(p) | Эффективность E(p) | \
| SEQ | 1 | 2.345 | 1.00 | — | \
| MPI | 2 | 1.214 | 1.93 | 96.5 % | \
| MPI | 4 | 0.643 | 3.65 | 91.2 % | \
| MPI | 8 | 0.337 | 6.96 | 87.0 % |

-- -

## 6. Интерпретация результатов

Распараллеливание даёт заметное ускорение.

Причины, по которым эффективность не достигает 100 % при большем числе процессов:

- Алгоритм имеет низкую вычислительную плотность(мало операций на один элемент сетки) 
- Высокие накладные расходы на коммуникацию между процессами - Данные распределены только по одной оси(ось X), что ограничивает масштабируемость

В целом, MPI - версия позволяет существенно ускорить вычисление интеграла на больших сетках.

## 7. Заключение

В ходе работы были выполнены следующие задачи :

- Разработаны последовательная(SEQ)
и параллельная(MPI)
реализации метода трапеций для вычисления двумерного интеграла.

- Проведена функциональная проверка корректности работы обеих реализаций, показавшая совпадение результатов.

- Выполнен анализ производительности MPI - версии на крупной сетке(2000 × 2000), показавший значительное ускорение по сравнению с последовательной реализацией.

- Выявлены причины неполной эффективности при большом числе процессов: низкая вычислительная плотность и накладные расходы на коммуникацию, а также ограниченное распределение данных по одной оси.

В целом, работа продемонстрировала, что распараллеливание метода трапеций с использованием MPI позволяет значительно ускорить вычисление интегралов на больших областях.
