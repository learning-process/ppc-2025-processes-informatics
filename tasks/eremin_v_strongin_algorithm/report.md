# Алгоритм глобального поиска (Стронгина) для одномерных задач оптимизации. Распараллеливание по характеристикам.

- **Студент:** Еремин Василий Егвеньевич, группа 3823Б1ФИ2
- **Технология:** SEQ | MPI
- **Вариант:** №11

## 1. Введение

**Цель работы:** Реализация и сравнительный анализ последовательной и параллельной версий алгоритма Стронгина для поиска глобального минимума функции на заданном отрезке.

**Задачи:**
1. Реализовать последовательную версию алгоритма Стронгина.
2. Реализовать параллельную версию с использованием технологии MPI.
3. Провести сравнительный анализ производительности и эффективности обеих реализаций.

## 2. Постановка задачи

**Задача**: Найти глобальный минимум непрерывной функции $f(x)$ на отрезке $[a,b]$ с заданной точностью ϵ или за ограниченное число итераций

**Описание метода решения:**
Алгоритм Стронгина — это итерационный метод, который на каждом шаге использует информацию о всех предыдущих испытаниях для выбора следующей точки. Основная идея заключается в вычислении **характеристики** каждого интервала между соседними точками. Характеристика отражает вероятность нахождения глобального минимума внутри данного интервала.


**Входные данные:**
- `lower_bound` ($a$), `upper_bound` ($b$) — границы поиска.
- `epsilon` ($\epsilon$) — требуемая точность.
- `max_iterations` — ограничение на количество шагов.
- `objective_function` ($f(x)$) — минимизируемая функция.

**Выходные данные:**
- Минимальное найденное значение функции на отрезке.

**Ограничения:** - Границы отрезка: $[-10^9, 10^9]$
- Максимальное число итераций: $100,000,000$

## 3. Описание алгоритма (последовательного)

**Алгоритм работы:**
1. **Инициализация:** Вычисляются значения функции в граничных точках $a$ и $b$.
2. **Оценка константы Липшица:** На основе всех проведенных испытаний вычисляется наклон:
   $$M = \max \frac{|f(x_i) - f(x_{i-1})|}{x_i - x_{i-1}}$$
3. **Параметр плотности:** $m = r \cdot M$ (где $r > 1$ — параметр надежности, в реализации $r=2.0$).
4. **Вычисление характеристик:** Для каждого интервала $(x_{i-1}, x_i)$ рассчитывается значение $R_i$.
5. **Выбор нового испытания:** Выбирается интервал с максимальным $R_i$, и внутри него вычисляется новая точка $x_{new}$.
6. **Критерий остановки:** Если длина максимального интервала становится меньше $\epsilon$ или достигнут лимит итераций.


## 4. Схема распараллеливания (MPI)

Основная вычислительная нагрузка в алгоритме приходится на перебор всех интервалов для поиска константы Липшица и расчет характеристик.

**Алгоритм параллельного вычисления:**
1. **Рассылка параметров:** Процесс 0 получает входные данные и рассылает их всем остальным через `MPI_Bcast`.
2. **Распределенный поиск наклона:** Каждый процесс обходит свою часть интервалов (с шагом `size`), вычисляя локальный максимум $M_{local}$.
3. **Глобальная синхронизация:** С помощью `MPI_Allreduce` находится общее значение $M$ для всех процессов.
4. **Параллельный расчет характеристик:** Процессы вычисляют $R_i$ для "своих" интервалов и находят локальный максимум характеристики.
5. **Выбор лучшего интервала:** Используется `MPI_Allreduce` с операцией `MPI_MAXLOC` для нахождения индекса интервала с глобально максимальной характеристикой.
6. **Обновление данных:** Процесс 0 вычисляет новую точку и её значение, затем рассылает их всем (`MPI_Bcast`). Все процессы синхронно вставляют точку в свои локальные векторы.
**Принцип разделения отрезков:**

```cpp

for (std::size_t i = 1 + rank; i < search_points.size(); i += size) {
    // Вычисления для конкретного интервала i
}
```

## 5. Детали реализации
**Дополнительные функции в тестах:**
- **MPI_MAXLOC:** Позволяет эффективно находить не только значение максимальной характеристики, но и ранг процесса/индекс интервала, которому она принадлежит.
- **Динамические массивы:** Использованы `std::vector` для хранения точек испытаний.
- **Устойчивость:** Добавлена проверка, чтобы новая точка $x_{new}$ не выходила за границы интервала из-за погрешностей типа `double`.

## 6. Экспериментальная среда
- **Hardware/OS:** Apple M1 Pro, 6 ядер производительности и 2 эффективности, 16 ГБ, Ubuntu 24.04.2 (DevContainer)
- **Toolchain:** GCC 13.3.0, C++20, CMake 3.28.3, build type Release
- **Environment:** `PPC_NUM_PROC` = 8

## 7. Результаты и обсуждение

### 7.1 Проверка корректности

**Методы верификации корректности:**

1.  **Сравнение с эталоном:**
    * Используются аналитически известные точки минимума для тестовых функций.
    * Проверка осуществляется через `expected_result_` в юнит-тестах.

2.  **Автоматизированное тестирование:**
    * Реализованы тесты для 5 различных сценариев, включающих тригонометрические, полиномиальные и экспоненциальные функции.
    * Сравнение последовательной (SEQ) и параллельной (MPI) версий подтверждает идентичность логики.

3.  **Допустимая погрешность:**
    ```cpp
    double tolerance = 1e-2;
    return std::abs(output_data - expected_result_) <= tolerance;
    ```
    * Установленная точность позволяет нивелировать разницу в точности вычислений `double` на разных архитектурах и учитывать дискретность шага алгоритма.
**Тестовые случаи:**
* **Интервалы:** от узких $[-5, 5]$ до широких $[-2, 100]$.
* **Функции:**
    * $f(x) = x^2$ — классическая парабола.
    * $f(x) = \sin(x)$ — периодическая функция с множеством локальных экстремумов.
    * $f(x) = x^4 - 3x^2$ — функция с двумя симметричными минимумами.
    * $f(x) = e^x$ — монотонная функция (минимум на границе).

**Результат:** Все тесты проходят успешно, что подтверждает корректность обеих реализаций.

### 7.2 Производительность

- **Сложная тестовая функция:** $f(x) = 0.002 \cdot x^2 + 5 \cdot \sin(30 \cdot x) + \sin(200 * \sin(50 \cdot x)) + 0.1 \cdot \cos(300 \cdot x)$
- **Лимит итераций:** `40 000`
- **Точность (epsilon):** `0.0001`

**Полученные результаты:**

| **Режим** | **Количество процессов** | **Время, с** | **Speedup** | **Efficiency** |
|-----------|--------------------------|--------------|-------------|----------------|
| SEQ       | 1                        | 4.25         | 1.00        | N/A            |
| MPI       | 2                        | 2.83         | 1.57        | 79%            |
| MPI       | 4                        | 2.22         | 2.00        | 50%            |
| MPI       | 6                        | 2.81         | 1.58        | 26%            |


## 8. Заключение

В ходе выполнения работы были успешно реализованы последовательная и параллельная (MPI) версии алгоритма Стронгина для глобальной одномерной оптимизации. 

Основные выводы:
* Параллельная версия корректно находит глобальный минимум функции наравне с последовательной, что подтверждено набором автоматизированных тестов.
* Реализованная схема распараллеливания по характеристикам интервалов демонстрирует стабильное ускорение на многоядерных системах.
* Выявлено, что для алгоритмов с высокой частотой синхронизаций (как в случае с методом Стронгина) оптимальное число процессов ограничено балансом между вычислительной сложностью целевой функции и задержками обмена данными в MPI-среде.

Данная реализация может быть использована для ускорения поиска экстремумов в задачах, где вычисление целевой функции является ресурсоемкой операцией.

## 9. Источники
1. [Презентация по курсу](https://learning-process.github.io/parallel_programming_slides/slides/01-intro.pdf)
2. [Wikipedia](https://ru.wikipedia.org/wiki/Метод_Стронгина)
