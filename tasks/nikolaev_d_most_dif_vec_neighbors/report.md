# Нахождение наиболее отличающихся по значению соседних элементов вектора

- Студент: Николаев Денис Андреевич, группа 3823Б1ФИ1
- Технология: SEQ | MPI
- Вариант: 8

## 1. Введение
В данной лабораторной работе исследуется задача нахождение наиболее отличающихся по значению соседних элементов в векторе. Для решения данной задачи были реализованы 2 алгоритма - последовательный (SEQ) и параллельный (MPI).

## 2. Постановка задачи
Дан вектор из n целых чисел. Требуется найти пару соседних элементов с максимальной разницей между ними diff = abs(v_i+1 - v_i).

Формат входных данных - std::vector\<int> - входной вектор с целыми значениями, формат выходных данных - std::pair<int, int> - пара элементов из входного вектора с наибольшой разницей между ними.

Ограничения:
- Входной вектор должен иметь хотя бы 2 элемента внутри (1 пара)

## 3. Базовый алгоритм (Последовательный)
Последовательный алгоритм проходит по всем элементам входного вектора v от 0 до n-2 и высчитывает diff = abs(v[i+1] - v[i]) и сравнивает с max_diff. Если diff > max_diff, то сохраняем найденую пару (v[i], v[i+1]) в result_elements.

## 4. Схема распараллеливания
Входной вектор разбивается на непрерывные сегменты между процессами. Каждый процесс получает свой сегмент элементов c помощью `MPI_Scatterv`, при этом распределение осуществляется так, чтобы разница в количестве элементов на каждый процесс была не более одного.

Каждый процесс находит максимальную разность между соседними элементами в своем сегменте и сохраняет пару элементов с максимальной разностью и граничные элементы сегмента. Используется `MPI_Gather` для сбора локальных результатов на нулевом процессе. Каждый процесс передает структуру с результатами своего сегмента.

Нулевой процесс выбирает максимальную разность из локальных результатов, при этом также обрабатывая граничные пары. После определения глобальной пары элементов с максимальной разностью, используется `MPI_Bcast` для рассылки финального результата всем процессам.

## 5. Детали реализации
Структура кода:

- ppc-2025-processes-informatics/tasks/nikolaev_d_most_dif_vec_neighbors/seq/src/ops_seq.cpp - последовательная реализация
- ppc-2025-processes-informatics/tasks/nikolaev_d_most_dif_vec_neighbors/mpi/src/ops_mpi.cpp - MPI реализация

Тесты:
- ppc-2025-processes-informatics/tasks/nikolaev_d_most_dif_vec_neighbors/tests/functional/main.cpp - функциональные
- ppc-2025-processes-informatics/tasks/nikolaev_d_most_dif_vec_neighbors/tests/performance/main.cpp - на производительность

Особенности:
- Код корректно обрабатывает случай, когда процессов больше, чем элементов. Лишние процессы просто не задействуются во время различных обработок. 
- Разница в количестве элементов на каждый процесс не превышает одного. Первые `remainder` процессов получают по одному дополнительному элементу.

## 6. Эксперементальное окружение
### 6.1 Оборудование
- CPU: AMD Ryzen 5 2600 (6 cores, 12 threads, 3.4 GHz)
- RAM: 16 GB
- OS: Windows 10, сама программа была запущена через WSL2 на Ubuntu 24.04.2 LTS.
- Toolchain: GCC 13.3.0, Release build

### 6.2 Генерация данных
- Вектор из n = 10'000'000 целочисленных чисел
- Числа загружаются в вектор из файла `test_vec.txt`
- Диапазон значений от -10'000 до 10'000

На двух соседних позициях в этом файле стоят числа -15'000 и 15'000, что делает разницу между ними гарантировано максимальной.


## 7. Результаты и обсуждение

### 7.1 Проверка корректности
Корректность работы алгоритмов и их производительность проверялись с помощью:
- Функциональных тестов с заранее известными результатами
- Тесты производительности - для измерения производительности/времени выполнения работы алгоритмом

Обе версии алгоритма тестировались на идентичных наборах входных данных для обеспечения корректности сравнения.


### 7.2 Производительность
n = 10'000'000
| Mode        | Count | Time, s | Speedup  | Efficiency |
|-------------|-------|---------|----------|------------|
| seq         | 1     | 0.0129  |  1.00    | N/A        |
| mpi         | 2     | 0.0159  |  0.81    | 40.5%      |
| mpi         | 4     | 0.0176  |  0.73    | 36.5%      |
| mpi         | 8     | 0.0253  |  0.51    | 6.4%       |

По результатам из таблицы можно сделать вывод, что параллельная реализация неэффективна, так как параллельные версии работают медленее последовательной (ускорение < 1, а именно 0.51-0.81).

Возможные причины низкой производительности:
- Высокие накладные расходы - операции `MPI_Scatterv`, `MPI_Gather`, `MPI_Bcast` для данного объема вычислений занимают больше времени, чем сами вычисления.
- Объем данных слишком мал для получения выигрыша от распаралеливания.
- Алгоритм линейный O(n), в котором используются несложные операции, что делает его менее подходящим для распараллеливания.

Для данного объема данных (10М элементов) оптимальнее использовать последовательную версию, так как параллельная дает только проигрыш в производительности.


## 8. Заключение
В рамках данной работы была успешно решена задача нахождение наиболее отличающихся по значению соседних элементов в векторе. Для решения данной задачи были успешно реализованы 2 алгоритма - последовательный (SEQ) и параллельный (MPI).

В итоге, MPI-версия показала хуже, нежели последовательная реализацией. Из-за совокупности различных факторов параллельная реализация нецелесообразна для малого объема данных. Тем не менее, обе реализации корректно проходят функциональные тесты.

## 9. Список литературы
1. MPI Forum. **MPI: A Message-Passing Interface Standard. Version 3.1** [Электронный ресурс]. — Режим доступа: https://www.mpi-forum.org/docs/
2. Лекции по параллельному программированию
3. Практические занятия по параллельному программированию